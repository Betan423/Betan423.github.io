
[{"content":"\r今年是我第一次參加HITCON，而我有幸能順利錄取學生免費方案，這邊再次感謝HITCON官方\r感想 #\r這邊先改一下順序，先講一下這次活動的感想，對於本活動有興趣的話可以再去閱讀下面的相關介紹\n這次的badge電路板、各種的攤位活動也都很有趣，議程也是有讓我了解了許多新東西，而且免費早餐跟點心也很都好吃👉👈 因為自己本身還是NISRA的幹部，因此其實這次主要是待在社群攤位，中間也有去聽了幾場自己感興趣的議程 這次活動讓我收穫許多，無論是badge的遊戲闖關、各種攤位活動、相關議程等，都讓我認識了許多全新的人，已經學習到了許多自己以前從未接觸過的方面\n我認為HITCON CMT是十分適合不論你是剛入門資安，又或是已經對於資安有一定的了解都可以來參加\n資安新手 #\r對於剛入門的人來講，在這邊能夠去聽一些自己有興趣的議程，了解該方面的未來發展、相關技術等，又或是可以到處認識一堆大佬，結交一些新朋友，讓你在資安的道路上不孤獨，畢竟會來HITCON的人或多或少都是對於資安有興趣的人，建議大家不要害羞，可以勇敢一點去多跟不論是社群攤位的社團、贊助商攤位，又或是你想在路上隨機搭訕路人也不是不行 (X\n資安老手 #\r而對於已經有一定程度的人來講，也能去多聽一些較為技術面向的議程，更重要的是如果平常有在打CTF的話，可以在現場看到一堆平常比賽時會遇到的賽棍\n也可以多去跟社群攤位聊一聊，或是參與他們的攤位活動，攤位的活動是比較技術取向的，也可以去激進自己的能力看看\n又或是要跟他們直接面試應該也不是不行\nHITCON #\r這邊先簡單介紹一下HITCON是甚麼 HITCON aka 台灣駭客年會 Hacks In Taiwan Conference\n今年(2024)為HITCON舉辦的第20周年(啪機啪機啪機)\n而HITCON活動內容我認為主要可以分成下列三個部分\n分別是 議程、社群攤位、贊助商攤位\n社群攤位 #\r社群攤位裡面主要是各校社團、資安相關社群等\n像是就有HITCON GIRLS、成大資安社(B33F 50UP戰隊)、中電會\u0026hellip;　當然還有我所在的NISRA攤位 雖然我也在B33F 50UP戰隊就是了\n其實滿建議大家沒事就可以多來這邊跟各大社群做交流，如果你還是高中生的話，可以前往中電會與他們稍作交流，而如果你是大學生也可以去到TSC的攤位去做一些了解之類的\n當然也很歡迎去其他各大攤位去了解他們在幹嘛，我自己是滿開心如果有人來我們攤位的啦，相信其他攤位基本上也都是這樣，因此也建議大家不要害羞，盡量去多多與大家交流，而且還可以拿很多攤位的酷酷獎品(X\n贊助商攤位 #\r這邊主要是各大有贊助的廠商能夠來到這邊擺攤、介紹他們的公司，攤位也會有一些小活動，像是DEVCORE的套圈圈之類的。\n也能向各大攤位詢問一些他們公司的事項、或是你好奇的東西之類的\n其實基本上與社群攤位滿像的 只是變成是由公司擺攤\n議程 #\r這次去聽了很多場議程，而許多議程都不是用中文在講，但大家可以放心，現場都有開放同步口譯，因此也不用害怕自己聽不懂，反而還可以去接觸到平常很難有機會聽到的外文議程，也還可以多多訓練自己的外語聆聽能力(X\n但這邊主要介紹兩場印象比較深刻的議程，分別是Evasive attacks against AI-powered antivirus software - Yu Arai 、 Background of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda\nEvasive attacks against AI-powered antivirus software - Yu Arai #\r這場議程主要是在介紹，他是如何bypass掉現在市面上現有的使用AI與傳統檢測技術的防毒軟體，以及最後也帶我們去思考了一下，會想繞過防毒是未來一定會面對到的議題，也因此該如何避免他們去繞過防毒也是一個很好也很重要的重點。\n而其實印象深刻的點主要有兩點，第一點是因為這場是日文的議程，本來以為自己可以不用靠翻譯就聽懂， 結果發現自己聽得懂的日文也就只有動漫那幾句\n而第二點其實是因為我今年AIS3專題做的部分也有點類似是在去靜態分析惡意軟體，因此發現自己做的類似的東西居然就這樣被bypass掉了，也有點震驚\nBackground of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda #\r這場是請到有在youtube拍攝影片的Yuda來做講師，而本場議程主要是在介紹說他們在遊戲中是如果去挖掘、發現一些獨特的漏洞(GLITCH)，以及一些相關經驗分享等\n我認為這是一場很特別很酷的議程，他並非像是傳統常見的議程，他反而沒有特別介紹許多技術相關的內容，但是我覺得其中挖掘漏洞所需要的思考及創新結合，是資安人會滿需要具備的能力，就是能跳脫傳統思考的樣子，總之是場很棒的議程\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/005_2024hitcon/","section":"Posts","summary":"2024 HITCON心得","title":"2024 HITCON心得","type":"posts"},{"content":"嗨 我是貝坦\n想要我的flag嗎 去找吧 我都藏在這裡ㄌ\n上次更新時間: 2024-08-27\r","date":"27 August 2024","externalUrl":null,"permalink":"/","section":"betan423.github.io","summary":"嗨 我是貝坦","title":"betan423.github.io","type":"page"},{"content":"","date":"27 August 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\rAIS3 a.k.a. 大型網友見面會\n好好玩 明年還去\r前言 #\r這是我第一次參加AIS3 結果就不小心被我蹭到最佳專題獎了\n在這邊再次感謝小蔡、萊姆跟l3obo三位隊友的凱瑞\n專題 #\r主題發想 #\r我這次是選到情資運用及防護，組別為B8\n當初完全就是被這個看起來很酷的名子騙進來的，完全不知道這個在幹嘛 這也就導致我們專題主題想到了第二天才勉強定案，然後這邊要再跟我的組員道歉一次\n因為其實我一直想做有關惡意軟體的製作跟分析之類的，所以我算是有點堅持(?)的一直不放棄這個主題，結果最後也真的被我盧成功了\n最後的主題就是基於聚類分析技術的惡意程式變體辨識方法研究\n感謝勝舢助教協助主題發想🛐\n製作過程 #\r我負責的部分算是進行資料的前處理以及資料的後續消化分析\n所以後面他們在做分析的時候我的工作內容就變成了問有沒有人要吃起司\n報告 #\r我們大概是最後一天下午才開始慢慢做簡報的，我只能跟大家說\n完 全 做 不 完\n因為其實我對做簡報也沒有到很熟，加上對主題也有點迷茫，因此其實改了很多次\n然後重要的一件事一定要試報，而且我是覺得需要不只一次\n其實我在真的試報以後才發現自己在時間的掌握、說話的結構上都還有很多很多的問題，所以後面就是開始瘋狂審稿加一直練習報自己的部分\n那個時候突然在想，我怎麼把報告報到跟在跑speedrun一樣 一直在瘋狂壓時間 這邊也謝謝三角蛇跟pwn2ooown兩位助教有聽我們試報\n但結果最後報告時間還是沒捏好，大概多講了40秒以上;(\n我給自己報告的分數大概只有6/10\n總結 #\r我覺得AIS3其實滿適合像我這種，剛接觸有點概念了，但還是不太確定未來具體方向的人\n像我這種人來了AIS3就是兩個結果，一是確認自己未來方向；二是放棄資安\n本來是差點變成二了 但最佳專題獎讓我決定做資安這塊做到死了\n然後真的建議大家要住宿，晚上跟組員討論專題也是精華之一，我就有看到一組他們有組員沒住宿 我根本沒看過他們第四個組員\n又卷 #\rAIS3到底卷不卷，來這裡到底會不會爆肝？ 卷，卷死了。拜託大家不要再卷了\u0026hellip;\n累死 #\r其實我覺得來AIS3會不會爆肝是要看個人欸\n看你追求什麼吧，如果目標是最佳專題的話當然是會很累\n但如果你只是想要來學習知識跟找到方向的話其實是可以不用那麼累的，但當然要跟自己專題的組員好好協調、溝通好\n不過都來了那目標當然是要放在最佳專題上吧\n廢話時間 #\r本來剛報告完是滿絕望的 我覺得自己講得很爛 而且時間也沒抓好 所以絕望之下就有了下面這張\n結果最後還真的拿到了\n寫共筆真的很好玩，雖然感覺大家都只是把講師的報告打上去而已\n在下面註釋的地方聊天真的很好玩\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/003_2024ais3/","section":"Posts","summary":"AIS3 讚  我是好駭客","title":"2024 AIS3心得","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/code/","section":"Tags","summary":"","title":"Code","type":"tags"},{"content":"\n因為最近dc很多音樂機器人都壞掉\n一氣之下就直接透過chatGPT寫一個出來了\r前言 #\r其實真的沒啥技術含量，因為代碼真的都是叫GPT幫我搓出來的\n但還是想說丟上來好了，畢竟在自己本地架機器人就不用看其他人的臉色了 (X 基本上會從頭開始講如何建立，但有些我沒碰到的功能就不會特別介紹\n因為我自己也不懂\n想抄代碼的可以直接跳到那邊就好了\n但還是放一下跟GPT溝通的流程之類的 水一下內容\n建立DC機器人 #\r首先先到\rDiscord Developer Portal 建立一個機器人出來\n登入後左上角New Application點下去，再取個名子，專屬你ㄉ機器人就誕生了\nNew Application\r剛進去就可以先看到設定的介面，這邊基本上就是可以設定機器人的名稱、頭貼、還有點進機器人會看到的描述\n然後DESCRIPTION的部分會在 關於我 的部分顯示 取得token #\r接著到旁邊選單選擇Bot\n在這邊可以額外設定機器人的橫幅(BANNER)\n而我們這邊主要要取得機器人的TOKEN\n點下去Reset Token確認後取得全新的token先自己記起來\n切記不要外洩 因為有token就能夠執行你的機器人了\nReset Token\r接著滑到下面Privileged Gateway Intents的部分，接著把三個選項都打勾\n這邊主要是要讓機器人能夠接收指令與用戶互動\n邀進伺服器 #\r進入OAuth2的部分，滑到最下面的OAuth2 URL Generator\n主要勾選bot就好\n而下面的BOT PERMISSIONS則是勾選Administrator\n直接拿所有權限就不用再慢慢設定了\nbot\rAdministrator\r再來往下看就可以在 GENERATED URL 看到你機器人的邀請連接了\n基本上機器人的部分就到這邊了 再來就是要寫code的部分了\n代碼 #\r安裝所需的庫 #\r打開你的cmd 一起快樂安裝\npip install discord.py youtube_dl pip install yt-dlp ffmpeg安裝 #\r前往\rBtbN FFmpeg Releases下載 ffmpeg-master-latest-win64-gpl.zip\n解壓縮後丟到一個不太會動到的地方\n接著打開環境變數，win11打開環境變數的方法如下\n設定 系統 系統資訊 進階系統設定 再來就能看到環境變數了\n接著選擇Path然後編輯，新增你剛剛解壓縮下來的檔案中bin資料夾的位置 (C:\\ffmpeg\\bin) 這樣就順利安裝完成了，可以檢查看看有沒有順利安裝，沒有的話就重開機看看\nffmpeg -version bot.py #\r主要可以分兩種撥放方式\n1.線上串流(較不穩定)\n2.下載到本機(很穩定)\n線上串流 #\r先講第一種線上串流的部分\n穩定性的部分就真的很爛 大概每首歌都撥不完 大概撥個一兩分鐘左右而已\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data) queue = asyncio.Queue() queue_urls = [] current_player = None # 用於儲存當前播放的音樂 @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Queue the song await queue.put(url) queue_urls.append(url) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {url}\u0026#34; for i, url in enumerate(queue_urls)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_list}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) # Optionally, automatically play the next song if not queue.empty(): await play_next_song(ctx, ctx.voice_client) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) async def play_next_song(ctx, voice_client): global current_player if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: player = await YTDLSource.from_url(url, loop=bot.loop, stream=True) current_player = player voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在撥放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song\u0026#39;) bot.run(\u0026#39;你的token\u0026#39;) 反正就又卡又容易斷掉 不如乖乖下載下來\n下載到本地 #\r因為是現在還有在用ㄉ，所以加了一些功能\n基本上就自己看一下code就能知道具體功能了 這邊就不多講了 然後下載到本地的話也不是全部下載，我是設定成一次本地只會有一首歌而已，然後撥下一首的時候就把前面的刪掉，所以不用怕自己電腦被灌爆 \u0026gt;.0\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio import os import datetime intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) self.duration = data.get(\u0026#39;duration\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data), filename queue = asyncio.Queue() queue_urls = [] current_player = None start_time = None downloaded_file = None # Only one file will be downloaded at a time @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Add the song to the queue await queue.put(url) queue_urls.append(url) # Get the song title to display the added message data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) await ctx.send(f\u0026#34;已將 {title} 加入待撥清單\u0026#34;) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = [] for url in queue_urls: data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) queue_list.append(title) queue_msg = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {title}\u0026#34; for i, title in enumerate(queue_list)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_msg}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) @bot.command() async def nowplay(ctx): if current_player: elapsed = (datetime.datetime.now() - start_time).total_seconds() elapsed_str = str(datetime.timedelta(seconds=int(elapsed))) duration_str = str(datetime.timedelta(seconds=int(current_player.duration))) progress_bar = create_progress_bar(elapsed, current_player.duration) await ctx.send(f\u0026#34;Now playing: {current_player.title}\\n{elapsed_str} {progress_bar} {duration_str}\u0026#34;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) def create_progress_bar(elapsed, duration, bar_length=20): progress = elapsed / duration bar = \u0026#39;-\u0026#39; * bar_length pos = int(bar_length * progress) progress_bar = bar[:pos] + \u0026#39;o\u0026#39; + bar[pos+1:] return progress_bar @bot.command() async def stop(ctx): if ctx.voice_client: if ctx.voice_client.is_playing(): ctx.voice_client.pause() await ctx.send(\u0026#39;已暫停播放.\u0026#39;) elif ctx.voice_client.is_paused(): ctx.voice_client.resume() await ctx.send(\u0026#39;已繼續播放.\u0026#39;) else: await ctx.send(\u0026#39;沒在播歌\u0026#39;) else: await ctx.send(\u0026#39;沒在語音中\u0026#39;) async def play_next_song(ctx, voice_client): global current_player, start_time, downloaded_file if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: # Delete the previous downloaded file if it exists if downloaded_file and os.path.isfile(downloaded_file): os.remove(downloaded_file) player, filename = await YTDLSource.from_url(url, loop=bot.loop, stream=False) current_player = player start_time = datetime.datetime.now() downloaded_file = filename # Update the downloaded file voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在播放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song.\u0026#39;) bot.run(\u0026#39;你ㄉtoken\u0026#39;) # 替換為你的實際 Bot Token 運行方法 #\r其實就只要運行py檔案就好了\n看你是要在cmd中執行還是直接在編譯器(我是用vs)跑都可以\npython bot.py 與chatGPT交流 #\r夢ㄉ開始 不知道為甚麼chatGPT一開始都是用java寫的，可能因為其實普遍都是用java寫吧，但我看不懂java所以都叫他寫python(\n其實好像也沒有甚麼特別要講的，基本上就都是想要什麼功能就講甚麼\n我覺得比較好玩的大概有nowplay功能而已 就是跟他說\u0026mdash;\u0026ndash;o\u0026mdash;-來表達進度條\n大概就這樣，有甚麼問題不要DM我，去問chatGPT這都他寫的(X\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/002_discordbot/","section":"Posts","summary":"謝謝ChatGPT讓我打遊戲的時候有歌可以聽","title":"DC音樂機器人製作","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r其實pre-exam也寫在這裡了 因為兩個沒差多少\r前言 #\r這次能打到前五真的覺得很不可思議，感覺今年題目有比較難\n雖然我也沒有打過之前的比賽就對了\n這次能打到第五名首先要特別感謝努力的自己 ，還有要特別感謝成大資安社還有B33F 50μP戰隊，提供了許多學習資源讓我學習 ，不過這次能打到那麼高真的覺得自己只是單純運氣好，比賽的時候想到比較多奇怪的方法，很多題還都是被我硬搓出來的\n而且賽後發現很多本來名次在我後面的，在pre-exam的名次都超過我了🛐\n建議想看比較正規解的人可以去看看別人的write up，我的真的都比較偏通靈向\n廢話夠多了，再來就進入到WriteUp的部分了\nScoreboard #\r先丟上自己的記分板還有賽後超長的記分板 我是MFCTF完整記分板\n我是pre-exam完整記分板\nMisc #\rWelcome #\r這次的Welcome沒有整活，單純點開題目描述就有了 flag:AIS3{Welc0me_to_AIS3_PreExam_2o24!}\n好歹也把pre-exam改成MFCTF吧 Quantum Nim Heist #\r這題是賽後在pre-exam才解出來的\r這題當初在MFCTF的時候是想說可能要先去破解他hash加密的部分\n然後自己找出把1加密後的結果再拿去讀檔\n所以MFCTF的時候想很久也沒有想出來該怎麼做\n結果賽後在pre-exam的時候無聊去亂試意外就找到破解的地方了\nsolve:\r如果一開始遊玩時亂輸入的話會顯示錯誤，因此就先正常進行遊戲動個幾步，後面直接按enter就會發現沒有報錯，而且對手也會動下一步\n因此再來就是等對手動到剩下最後一排的時候再去收割就好了 flag:AIS3{Ar3_y0u_a_N1m_ma57er_0r_a_Crypt0_ma57er?} Reverse #\rThe Long Print #\r先透過IDA查看反編譯後的代碼，主要可以發現在輸出的部分會重複執行sleep，因此無法直接透過執行來查看flag ，並且可以看到flag應該是存在v4也就是rsp的部分\n這邊再特別解釋一下，因為從上面反編譯後可以看到輸出後會再做V4\u0026gt;\u0026gt;=8的動作 因此這邊就是每次察看rsp的末兩位就好了 我一開始是透過gdb來在sleep的地方下斷點，然後直接jump到下一行，結果發現最後拚出來的flag怪怪的 其實這邊這個方法也可以 只是我當時看錯東西\n所以又去嘗試透過IDA先找到sleep的地方換成16進制檔案時在哪，再透過010Editor把那部分改成90，也就是不進行任何動作(這部分等等的火拳也會用到，會再詳細介紹)\nsolve:\r兩個方法其實後面要做的事情都差不多，都一樣是丟到gdb裡面，然後再printf的地方下斷點，並查看當時rsp的質，最後再轉成ASCII字元就好了 所以再來就一樣慢慢把flag搓出來 $rsp 的質: 0x3353494100000000 0x756f597b00000000 0x6572615f00000000 0x6568745f00000000 0x73616d5f00000000 0x5f72657400000000 0x745f666f00000000 0x5f656d6900000000 0x616e616d00000000 0x656d656700000000 0x2121746e00000000 0x7d3f212100000000 flag: AIS3{You_are_the_master_of_time_management!!!!?}\n火拳のエース #\r特別感謝Kazma在讀書會上分享angr這個工具 這題是透過angr來快速解出來的 Kazma的angr教學\n也沒有到秒解 還是想了很久\nsolve:\r一樣都先透過IDA查看反編譯後的代碼，發現跟之前自己練習angr官方Lab006使用到的觀念都差不多 主要都是把數據存在動態內存再去做混淆\r題目: lab006: 所以這邊直接偷Lab006的解來稍作修改\nimport angr import claripy import sys def main(argv): path_to_binary = argv[1] project = angr.Project(path_to_binary) start_address = 0x08049661 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password0 = claripy.BVS(\u0026#39;password0\u0026#39;, 64) password1 = claripy.BVS(\u0026#39;password1\u0026#39;, 64) password2 = claripy.BVS(\u0026#39;password2\u0026#39;, 64) password3 = claripy.BVS(\u0026#39;password3\u0026#39;, 64) fake_heap_address0 = 0xffffc93c pointer_to_malloc_memory_address0 = 0x090FB2D4 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness) fake_heap_address1 = 0xffffc94c pointer_to_malloc_memory_address1 = 0x090FB2D8 initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness) fake_heap_address2 = 0xffffc95c pointer_to_malloc_memory_address2 = 0x090FB2DC initial_state.memory.store(pointer_to_malloc_memory_address2, fake_heap_address2, endness=project.arch.memory_endness) fake_heap_address3 = 0xffffc96c pointer_to_malloc_memory_address3 = 0x090FB2E0 initial_state.memory.store(pointer_to_malloc_memory_address3, fake_heap_address3, endness=project.arch.memory_endness) initial_state.memory.store(fake_heap_address0, password0) initial_state.memory.store(fake_heap_address1, password1) initial_state.memory.store(fake_heap_address2, password2) initial_state.memory.store(fake_heap_address3, password3) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;Yes! I remember now, this is it!\u0026#39; in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;It feels slightly wrong, but almost correct...\u0026#39; in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode() solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode() print (solution0,solution1,solution2,solution3) else: raise Exception(\u0026#39;Could not find the solution\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main(sys.argv) 這邊不特別解釋angr的代碼在做什麼\n有興趣的話我應該會在下下學期在NISRA上相關課程 敬請期待\n接著透過剛剛LongPrint提到的，透過16進制編輯器先把print_flag的部分刪掉，因為這邊我們直接透過strings就可以看到前半部分了 具體刪除的方法是先透過IDA在欲刪除的部分下斷點，然後開啟debug模式，接著到設定將Number of opcode bytes設成6，接著切回去就可以看到該段位於十六進制檔案中的何處了 接著就拿腳本去跑一次修改過後的檔案，發現居然錯了 後面想說那不如乾脆把與lab不同的地方(進行xor的部分)也乾脆先刪掉好了，因此重複上述操作，再去跑一次腳本，發現這次就有順利出現結果了！ 那接著就是把得到的質丟回去還有xor的檔案，接著透過gdb在進行xor後下斷點，查看xor後的質是多少 那最後flag也是順利被我搓出來了 這題大概是我這次最正規的解法了 flag:AIS3{G0D_D4MN_4N9R_15_5UP3R_P0W3RFU1!!!} Web #\rEvil Calculator #\rsolve:\r連進去發現是一個計算機，就很普通的計算機\r接著透過burp suite攔截發送1+1過去時的封包並送到Repeater查看 接著就嘗試修改1+1的部分，我先是嘗試看看能不能單純輸出字元，或是符號之類的 發現好像不能直接輸出，那接著猜測是不是只能數字，因此這邊使用簡單的len來查看，發現可以正常輸出，因此推測只要是轉成數字輸出後就可以 接著就根據題目給的檔案，知道了flag是在前一個目錄裡面，因此就嘗試結合len、read、跟Path Traversal去讀看看，發現也可以正常執行，並且知道了flag的長度為31 再來我的想法是，一個一個讀取flag的字元，因此一樣使用read只是將len改成ord來查看該字元換成ASCII為多少，但發現會報錯\n這邊直接把報錯貼到google去看，了解原來是因為直接read後就已經是數字了，不需要再透過ord去轉 因此最後直接就把ord去掉，再次察看就會發現有正常輸出了！\n然後就重複這個操作31次 flag就被我搓出來了呢 flag:AIS3{7RiANG13_5NAK3_I5_50_3Vi1}\nCrypto #\rbabyRSA #\r這題也是被我硬搓出來的 我對不起大家\nsolve:\r這邊先查看原代碼，可以發現它應該是對flag的每個字元去做個別加密的，因此最後輸出結果才會有那麼多\r這邊我想了很久，最後決定！\n對string.printable全部做一次加密 然後慢慢把flag對照搓出來 我的方法真的很笨 自己都看不下去的那種\nimport string def encrypt(pk, plaintext): key, n = pk cipher = [pow(ord(char), key, n) for char in plaintext] return cipher public=(64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) flag=string.printable print(flag) encrypted_msg = encrypt(public, flag) for i in range(len(flag)): print(flag[i],\u0026#34;=\u0026#34;,encrypted_msg[i]) 我是直接在記事本裡面慢慢用搜尋跟取代把flag搓出來啦，因為那個時候比賽快結束了，也懶得去想程式碼要怎麼寫，所以這邊就直接藉助了工人智慧 而且flag檔案的第一碼還不是A 害我當初困惑超久 所以後面才決定直接把全部都硬搓出來\nflag:AIS3{NeverUseTheCryptographyLibraryImplementedYourSelf}\n好欸終於寫完了\n然後如果發現我上述有錯誤的地方 都歡迎私訊我提醒我改一下\n相關問題 #\r這邊會比較偏我當初行前自己有疑惑的點，算是半個指引吧\r首先是交通的問題，這次舉辦的地點在救國團劍潭青年活動中心-集賢廳 (台北市中山北路四段16號)\n我自己是騎車過去啦，當初一直在想到底有沒有車位，後來其實發現在正門入口就有免費停車場了，而且還滿空的，因此大家可以放心騎車去了 再來是題目數量的部分，這次題目好像有比較多，以往好像都是各類型抓兩題，但這次是變成三題，不確定以後會不會也都是三題\n題目總覽 ","date":"30 June 2024","externalUrl":null,"permalink":"/posts/001_mfctf_writeup/","section":"Posts","summary":"2024ㄉMyFirstCTF跟pre-examㄉWriteUp","title":"2024 MyFirstCTF WriteUp","type":"posts"},{"content":"","date":"30 June 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"\r建立契機 #\r發現各大佬都有自己的網站，我也想要有一個\n當初打CTF在看別人寫的Write up就想著以後也要自己寫在部落格裡\n剛好想說可以創個地方來讓我寫各種資安相關的經歷\n因此這個網站主要內容也比較都會是以我的各種資安相關經歷為主\n網站簡介 #\r這個網站是透過\rHugo 建立，並套用了\rblowfish 主題\n然後我其實很不會寫網站 歡迎各位大神指導我\n網站歷史 #\r2024-5-27 網站創立\n","date":"31 May 2024","externalUrl":null,"permalink":"/intro/","section":"betan423.github.io","summary":"看看我ㄉ部落格歷史。","title":"網站簡介","type":"page"},{"content":"\r副標題\r大標題 #\r段落標題 #\r換行 文字內容\nNew article!\r按鈕\rBetan423/Betan423.github.io\rHTML 0\r0\r最近的文章\r2024 HITCON心得\r27 August 2024\r2024 HITCON心得\r2024 AIS3心得\r6 August 2024\rAIS3 讚 我是好駭客\rgraph LR;\rA[共通線]--\u003eB[八六];\rB--\u003eC[奧莉薇]\r","date":"23 April 2005","externalUrl":null,"permalink":"/%E9%A0%90%E8%A8%AD/","section":"模板","summary":"複製用模板","title":"模板","type":"預設"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"\r看看我給未來的自己畫了多少餅\r資安相關規劃 #\r學習malware 正在啃《Windows APT Warfare：惡意程式前線戰術指南》 學好reverse跟pwn CyberRange Master 但其實我根本沒接觸過 ","date":"1 January 0001","externalUrl":null,"permalink":"/future/","section":"betan423.github.io","summary":"我ㄉ未來規劃。","title":"未來規劃","type":"page"},{"content":"\n這我 #\r嗨我是貝坦，一個誤打誤撞跑去學資安的怪人\n當初對於資安這塊完全沒概念，但大學不小心上了一個名子很長的資安系， 在經過一學期的各種講座洗禮以及自己稍微了解後，發現對於資安好像滿有興趣的， 結果就栽進這個無底洞了。\n如何找到我 #\r如果你在有關資安的一些大型活動或比賽，看到一個穿著咖啡色襯衫、拿著一個棕色的1.2L的超大水壺，那那個高機率就是我了(X\n資安經驗 #\r2023-9 NISRA社員\n2024-4 加入B33F 50μP戰隊\n2024-8 參與2024 AIS3\n競賽經驗 #\r2024 My First CTF 銀質獎/第5名\n2024 AIS3 最佳專題獎\n","date":"1 January 0001","externalUrl":null,"permalink":"/authors/betan/","section":"Authors","summary":"","title":"我是貝坦betan","type":"authors"}]