
[{"content":"嗨 我是貝坦\n我想放假\n上次更新時間: 2024-09-26\r","date":"26 September 2024","externalUrl":null,"permalink":"/","section":"betan423.github.io","summary":"嗨 我是貝坦","title":"betan423.github.io","type":"page"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r耶其實我還有在牛肉湯讀書會發表這個\n其實滿廢的 對不起大家。\r動機 #\r這次的被害者是 SupermarketTogether\n這是一個模擬超市經營的遊戲，但這次的外掛跟這部分完全沒關係\n簡單來講在這個遊戲內有一個房間，是正常遊玩進不去，門口有空氣牆堵住\n然後房間內有一隻大象，下圖就是房間內的畫面\n總之我的目的就是要進去房間內，對就是那麼廢。\n進入房間內 #\r正常方法(? #\r一開始先去看了一下正常該如何透過遊戲內的bug卡進去房間內\n簡單來講就是透過unity其中的3D物件不斷重疊會發生穿模的bug來卡入房間內 具體如何進入的話可以查看下面這個影片的7:40的部分 https://www.bilibili.com/video/BV1XXeneoEcJ/\n透過CheatEngine #\rCheatEngine(以下簡稱CE)，是一個常用來改遊戲內參數的外掛工具，這邊不特別介紹\n參考影片的話可以看下列兩個，上面成大資安社的社課主要是介紹CE的基礎使用，下面的則是透過CE來找座標，建議搭配食用 小提醒：找座標時記得把類型改成float比較好找 那總之透過不斷搜尋後就可以找到控制x座標的部分了，接著把參數改成2.5即可進入房間內\n恭喜你也是很酷的人了 啪嘰啪嘰啪嘰\n值得一提的是，再找參數的時候有發現兩個控制座標的參數\n但其中一個改值後不會馬上生效，另一個則會\n最後推斷是，其中一個是主要控制的，另一個則有點像是附屬的感覺(?\nDLL #\r來到這次的重點了，前面單純透過CE來改參數的部分不論是速度還是什麼，缺點太多了\n因此這邊我們就來把它寫成DLL的形式，透過DLL injection來注入我們寫的壞壞的東西\n以此來達到按下特定按鍵就可以瞬移進入房間內的功能\n先丟一下github 裡面有這次的原碼及DLL Betan423/SupermarkerTogether-dll\r在B33F50UP讀書會上分享的外掛原始檔\rC\u0026#43;\u0026#43; 0\r0\r遇到問題 #\r本次遇到最大的問題是，每次開啟所佔用的的address都不同，因此也就不能單純透過一個固定修改某處address的DLL來打天下\n而我最初的想法是，會不會他只是base address不同，而其他彼此參數間的相對位置則是固定的\n如果參數間的相對距離是固定的，我們也就能透過先去尋找一個好找一點的值(像是金錢)，接著再透過他跟x座標彼此間的address差值，就能夠快速找出x座標的address了\n但在重複找了許多次金錢與x座標的address，發現他們彼此間的差值是沒有相關的qq\nmoney place 差值 12455A43E80 1222316B88C 2 328D 85F4 1CD5CB93BE0 1CB32953D08 2 2A23 FED8 1D652C40BE0 1D402B92B6C 2 500A E074 28FE89F9E80 28D82C0752C 2 65DF 2954 1AFDC3D4940 1ADA2B77B98 2 3985 CDA8 因此最後的方案就還是要先在開始時去尋找x座標的address，接著再透過輸入進去DLL內，來改變其中預設的address值(預設是寫0x0400000 但當然不可能是這邊)\nDLL說明 #\r最終DLL的步驟就是先透過讓用戶按下i來出現輸入address的對話框，接著修改後就能透過按下o來瞬移進房間內。按下l來離開房間內\n這邊可以搭配上面github內的final.cpp原始碼一起看，這邊就不特別貼整段原始碼了\n定義類型 #\r剛剛有提到我們是夠過float來改會比較方便，因此在最開頭的地方先定義好\n#define TYPE float 定義參數 #\r在上面先宣告好參數，在最後的時候給參數附值，也就是我們瞬移後要的座標是多少\nstruct Params { TYPE x_go; // 位置 TYPE y_go; TYPE x_back; TYPE y_back; }; ... g_params.x_go = 2.5f; g_params.y_go = 2.8f; g_params.x_back = 2.0f; g_params.y_back = 2.8f; 取得地址 #\r會跳出兩個對話框，一個是讓你輸入address的，一開始會顯示請輸入新的記憶體位址（十六進位）；另一個則是單純確認框，輸入好後按下去即可修改\nDWORD_PTR GetUserInputAddress() { //輸入部分 HWND hwndInput = CreateWindowEx( 0, L\u0026#34;EDIT\u0026#34;, NULL, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | ES_LEFT, CW_USEDEFAULT, CW_USEDEFAULT, 300, 100, NULL, NULL, GetModuleHandle(NULL), NULL ); SetWindowText(hwndInput, L\u0026#34;請輸入新的記憶體位址（十六進位）\u0026#34;); ShowWindow(hwndInput, SW_SHOW); UpdateWindow(hwndInput); char input[17] = { 0 }; // 確認部分 if (MessageBox(NULL, L\u0026#34;請輸入新的記憶體位址（十六進位）並按下確認\u0026#34;, L\u0026#34;輸入地址\u0026#34;, MB_OKCANCEL) == IDOK) { GetWindowTextA(hwndInput, input, sizeof(input)); DestroyWindow(hwndInput); return strtoull(input, NULL, 16); // 將輸入的十六進位字符串轉換為地址 } // 出錯返回原地址 DestroyWindow(hwndInput); return g_x_address; } 修改參數 #\r這邊就是結合上面兩個定義好的address以及先前設定的參數來修改內存的值了\nif (GetAsyncKeyState(\u0026#39;O\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_go, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_go, sizeof(TYPE), NULL); } if (GetAsyncKeyState(\u0026#39;L\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_back, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_back, sizeof(TYPE), NULL); } 總結 #\r耶大概就這樣，DLL外掛的衍伸應用還有很多，絕對不會只有單純這樣改參數這麼簡單，但窩不會，像是也可以透過掛個hook之類的來修改原本的運作方法\u0026hellip; 以後如果學到的話會再來寫布拉格的 大概\n","date":"26 September 2024","externalUrl":null,"permalink":"/posts/006_supermarketdll/","section":"Posts","summary":"把CE改參數部分寫成dll來注入","title":"超市一起瞬移DLL","type":"posts"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E8%B3%87%E5%AE%89/","section":"Tags","summary":"","title":"資安","type":"tags"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E9%81%8A%E6%88%B2%E5%A4%96%E6%8E%9B/","section":"Tags","summary":"","title":"遊戲外掛","type":"tags"},{"content":"","date":"23 September 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"\r假裝自己在參加鐵人賽\r前言 #\r這次參加的是 IERAE CTF ，其實本來是有報名三場CTF的，但最後只有這場解出比較多題(但也沒多少)，所以就專注寫這個了\n之後的步調應該也都會差不多是這樣，先報名2~3個CTF，最後再看要主打哥哪個\n本次排名 106/224 解出四題qq\n題目 #\rWelcome #\rflag在DC內，就單純進去找 :)\nOMG #\r類型: web\n一個網頁，然後只要按返回前一頁33次就可以了\nderangement #\r類型: crypto\n有一個隨機產生的16個字符，然後裡面會不斷隨機排列他們的順序，目標是找出正確的順序\n查看加密法後會發現字符不會出現在本來正確的地方，因此只要多跑幾次就可以順利得出本來的順序了\n本來是想硬搓的，但想說這樣沒甚麼用還是透過pwntool寫好了\nfrom pwn import * # 開啟程序 p = remote(\u0026#39;104.199.135.28\u0026#39;, 55555) # 用來存儲所有獲得的提示 hints = [] ans=\u0026#39;\u0026#39; p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;,\u0026#39;1\u0026#39;) response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() world = p.recvline().decode().strip() a = world b = world c = world d = world e = world f = world g = world h = world i = world j = world k = world l = world m = world n = world o = world time =0 try: while time\u0026lt;100: # 發送 \u0026#34;1\u0026#34; 來獲取提示 p.sendline(\u0026#39;1\u0026#39;) # 接收並解析提示 response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() hint = p.recvline().decode().strip() hints.append(hint) print(f\u0026#39;Received hint: {hint}\u0026#39;) # 可以在這裡添加邏輯來分析 hints 並推測原始魔法詞 if hint[0] in a: a = a.replace(hint[0], \u0026#34;\u0026#34;) if hint[1] in b: b = b.replace(hint[1], \u0026#34;\u0026#34;) if hint[2] in c: c = c.replace(hint[2], \u0026#34;\u0026#34;) if hint[3] in d: d = d.replace(hint[3], \u0026#34;\u0026#34;) if hint[4] in e: e = e.replace(hint[4], \u0026#34;\u0026#34;) if hint[5] in f: f = f.replace(hint[5], \u0026#34;\u0026#34;) if hint[6] in g: g = g.replace(hint[6], \u0026#34;\u0026#34;) if hint[7] in h: h = h.replace(hint[7], \u0026#34;\u0026#34;) if hint[8] in i: i = i.replace(hint[8], \u0026#34;\u0026#34;) if hint[9] in j: j = j.replace(hint[9], \u0026#34;\u0026#34;) if hint[10] in k: k = k.replace(hint[10], \u0026#34;\u0026#34;) if hint[11] in l: l = l.replace(hint[11], \u0026#34;\u0026#34;) if hint[12] in m: m = m.replace(hint[12], \u0026#34;\u0026#34;) if hint[13] in n: n = n.replace(hint[13], \u0026#34;\u0026#34;) if hint[14] in o: o = o.replace(hint[14], \u0026#34;\u0026#34;) ans=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o print(ans) if(len(ans)==15): p.sendline(\u0026#39;2\u0026#39;) p.sendline(ans) p.interactive() except Exception as e: print(f\u0026#39;Connection closed or error occurred: {e}\u0026#39;) finally: p.close() Assignment #\r類型: rev\n透過IDA打開可以看到順序被打亂的flag\n但打開F5後就可以看到排列好順序的flag了 總結 #\r這次其實都只有解出水題出來w\n但畢竟才第一周\n其實我也不知道這樣會不會有效果 但就先嘗試看看\n之後會再補充一些自己沒解出來的題目，但是去查看別人wu解出來的內容\n最後分享一個這次在比賽結束後看到的\n在講這次比賽crypto類型的題目，頻道內容也有其他資安相關的影片\n不過是日文的VT\n","date":"23 September 2024","externalUrl":null,"permalink":"/posts/005_weeklyctf01/","section":"Posts","summary":"你說的對但這就是CTF","title":"每周CTF計畫01","type":"posts"},{"content":"\r今年是我第一次參加HITCON，而我有幸能順利錄取學生免費方案，這邊再次感謝HITCON官方\r感想 #\r這邊先改一下順序，先講一下這次活動的感想，對於本活動有興趣的話可以再去閱讀下面的相關介紹\n這次的badge電路板、各種的攤位活動也都很有趣，議程也是有讓我了解了許多新東西，而且免費早餐跟點心也很都好吃👉👈 因為自己這次主要是有在協助NISRA擺攤，因此其實這次主要是待在社群攤位，中間也有去聽了幾場自己感興趣的議程 這次活動讓我收穫許多，無論是badge的遊戲闖關、各種攤位活動、相關議程等，都讓我認識了許多全新的人，已經學習到了許多自己以前從未接觸過的方面\n我認為HITCON CMT是十分適合不論你是剛入門資安，又或是已經對於資安有一定的了解都可以來參加\n資安新手 #\r對於剛入門的人來講，在這邊能夠去聽一些自己有興趣的議程，了解該方面的未來發展、相關技術等，又或是可以到處認識一堆大佬，結交一些新朋友，讓你在資安的道路上不孤獨，畢竟會來HITCON的人或多或少都是對於資安有興趣的人，建議大家不要害羞，可以勇敢一點去多跟不論是社群攤位的社團、贊助商攤位，又或是你想在路上隨機搭訕路人也不是不行 (X\n資安老手 #\r而對於已經有一定程度的人來講，也能去多聽一些較為技術面向的議程，更重要的是如果平常有在打CTF的話，可以在現場看到一堆平常比賽時會遇到的賽棍\n也可以多去跟社群攤位聊一聊，或是參與他們的攤位活動，攤位的活動是比較技術取向的，也可以去激進自己的能力看看\n又或是要跟他們直接面試應該也不是不行\nHITCON #\r這邊先簡單介紹一下HITCON是甚麼 HITCON aka 台灣駭客年會 Hacks In Taiwan Conference\n今年(2024)為HITCON舉辦的第20周年(啪機啪機啪機)\n而HITCON活動內容我認為主要可以分成下列三個部分\n分別是 議程、社群攤位、贊助商攤位\n社群攤位 #\r社群攤位裡面主要是各校社團、資安相關社群等\n像是就有HITCON GIRLS、成大資安社(B33F 50UP戰隊)、中電會\u0026hellip;　當然還有我這次有幫忙的NISRA攤位 雖然我也在B33F 50UP戰隊就是了\n其實滿建議大家沒事就可以多來這邊跟各大社群做交流，如果你還是高中生的話，可以前往中電會與他們稍作交流，而如果你是大學生也可以去到TSC的攤位去做一些了解之類的\n當然也很歡迎去其他各大攤位去了解他們在幹嘛，我自己是滿開心如果有人來我們攤位的啦，相信其他攤位基本上也都是這樣，因此也建議大家不要害羞，盡量去多多與大家交流，而且還可以拿很多攤位的酷酷獎品(X\n贊助商攤位 #\r這邊主要是各大有贊助的廠商能夠來到這邊擺攤、介紹他們的公司，攤位也會有一些小活動，像是DEVCORE的套圈圈之類的。\n也能向各大攤位詢問一些他們公司的事項、或是你好奇的東西之類的\n其實基本上與社群攤位滿像的 只是變成是由公司擺攤\n議程 #\r這次去聽了很多場議程，而許多議程都不是用中文在講，但大家可以放心，現場都有開放同步口譯，因此也不用害怕自己聽不懂，反而還可以去接觸到平常很難有機會聽到的外文議程，也還可以多多訓練自己的外語聆聽能力(X\n但這邊主要介紹兩場印象比較深刻的議程，分別是Evasive attacks against AI-powered antivirus software - Yu Arai 、 Background of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda\nEvasive attacks against AI-powered antivirus software - Yu Arai #\r這場議程主要是在介紹，他是如何bypass掉現在市面上現有的使用AI與傳統檢測技術的防毒軟體，以及最後也帶我們去思考了一下，會想繞過防毒是未來一定會面對到的議題，也因此該如何避免他們去繞過防毒也是一個很好也很重要的重點。\n而其實印象深刻的點主要有兩點，第一點是因為這場是日文的議程，本來以為自己可以不用靠翻譯就聽懂， 結果發現自己聽得懂的日文也就只有動漫那幾句\n而第二點其實是因為我今年AIS3專題做的部分也有點類似是在去靜態分析惡意軟體，因此發現自己做的類似的東西居然就這樣被bypass掉了，也有點震驚\nBackground of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda #\r這場是請到有在youtube拍攝影片的Yuda來做講師，而本場議程主要是在介紹說他們在遊戲中是如果去挖掘、發現一些獨特的漏洞(GLITCH)，以及一些相關經驗分享等\n我認為這是一場很特別很酷的議程，他並非像是傳統常見的議程，他反而沒有特別介紹許多技術相關的內容，但是我覺得其中挖掘漏洞所需要的思考及創新結合，是資安人會滿需要具備的能力，就是能跳脫傳統思考的樣子，總之是場很棒的議程\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/004_2024hitcon/","section":"Posts","summary":"2024 HITCON心得","title":"2024 HITCON心得","type":"posts"},{"content":"\rAIS3 a.k.a. 大型網友見面會\n好好玩 明年還去\r前言 #\r這是我第一次參加AIS3 結果就不小心被我蹭到最佳專題獎了\n在這邊再次感謝小蔡、萊姆跟l3obo三位隊友的凱瑞\n專題 #\r主題發想 #\r我這次是選到情資運用及防護，組別為B8\n當初完全就是被這個看起來很酷的名子騙進來的，完全不知道這個在幹嘛 這也就導致我們專題主題想到了第二天才勉強定案，然後這邊要再跟我的組員道歉一次\n因為其實我一直想做有關惡意軟體的製作跟分析之類的，所以我算是有點堅持(?)的一直不放棄這個主題，結果最後也真的被我盧成功了\n最後的主題就是基於聚類分析技術的惡意程式變體辨識方法研究\n感謝勝舢助教協助主題發想🛐\n製作過程 #\r我負責的部分算是進行資料的前處理以及資料的後續消化分析\n所以後面他們在做分析的時候我的工作內容就變成了問有沒有人要吃起司\n報告 #\r我們大概是最後一天下午才開始慢慢做簡報的，我只能跟大家說\n完 全 做 不 完\n因為其實我對做簡報也沒有到很熟，加上對主題也有點迷茫，因此其實改了很多次\n然後重要的一件事一定要試報，而且我是覺得需要不只一次\n其實我在真的試報以後才發現自己在時間的掌握、說話的結構上都還有很多很多的問題，所以後面就是開始瘋狂審稿加一直練習報自己的部分\n那個時候突然在想，我怎麼把報告報到跟在跑speedrun一樣 一直在瘋狂壓時間 這邊也謝謝三角蛇跟pwn2ooown兩位助教有聽我們試報\n但結果最後報告時間還是沒捏好，大概多講了40秒以上;(\n我給自己報告的分數大概只有6/10\n總結 #\r我覺得AIS3其實滿適合像我這種，剛接觸有點概念了，但還是不太確定未來具體方向的人\n像我這種人來了AIS3就是兩個結果，一是確認自己未來方向；二是放棄資安\n本來是差點變成二了 但最佳專題獎讓我決定做資安這塊做到死了\n然後真的建議大家要住宿，晚上跟組員討論專題也是精華之一，我就有看到一組他們有組員沒住宿 我根本沒看過他們第四個組員\n又卷 #\rAIS3到底卷不卷，來這裡到底會不會爆肝？ 卷，卷死了。拜託大家不要再卷了\u0026hellip;\n累死 #\r其實我覺得來AIS3會不會爆肝是要看個人欸\n看你追求什麼吧，如果目標是最佳專題的話當然是會很累\n但如果你只是想要來學習知識跟找到方向的話其實是可以不用那麼累的，但當然要跟自己專題的組員好好協調、溝通好\n不過都來了那目標當然是要放在最佳專題上吧\n廢話時間 #\r本來剛報告完是滿絕望的 我覺得自己講得很爛 而且時間也沒抓好 所以絕望之下就有了下面這張\n結果最後還真的拿到了\n寫共筆真的很好玩，雖然感覺大家都只是把講師的報告打上去而已\n在下面註釋的地方聊天真的很好玩\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/003_2024ais3/","section":"Posts","summary":"AIS3 讚  我是好駭客","title":"2024 AIS3心得","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/code/","section":"Tags","summary":"","title":"Code","type":"tags"},{"content":"\r因為最近dc很多音樂機器人都壞掉\n一氣之下就直接透過chatGPT寫一個出來了\r前言 #\r其實真的沒啥技術含量，因為代碼真的都是叫GPT幫我搓出來的\n但還是想說丟上來好了，畢竟在自己本地架機器人就不用看其他人的臉色了 (X 基本上會從頭開始講如何建立，但有些我沒碰到的功能就不會特別介紹\n因為我自己也不懂\n想抄代碼的可以直接跳到那邊就好了\n但還是放一下跟GPT溝通的流程之類的 水一下內容\n建立DC機器人 #\r首先先到\rDiscord Developer Portal 建立一個機器人出來\n登入後左上角New Application點下去，再取個名子，專屬你ㄉ機器人就誕生了\nNew Application\r剛進去就可以先看到設定的介面，這邊基本上就是可以設定機器人的名稱、頭貼、還有點進機器人會看到的描述\n然後DESCRIPTION的部分會在 關於我 的部分顯示 取得token #\r接著到旁邊選單選擇Bot\n在這邊可以額外設定機器人的橫幅(BANNER)\n而我們這邊主要要取得機器人的TOKEN\n點下去Reset Token確認後取得全新的token先自己記起來\n切記不要外洩 因為有token就能夠執行你的機器人了\nReset Token\r接著滑到下面Privileged Gateway Intents的部分，接著把三個選項都打勾\n這邊主要是要讓機器人能夠接收指令與用戶互動\n邀進伺服器 #\r進入OAuth2的部分，滑到最下面的OAuth2 URL Generator\n主要勾選bot就好\n而下面的BOT PERMISSIONS則是勾選Administrator\n直接拿所有權限就不用再慢慢設定了\nbot\rAdministrator\r再來往下看就可以在 GENERATED URL 看到你機器人的邀請連接了\n基本上機器人的部分就到這邊了 再來就是要寫code的部分了\n代碼 #\r安裝所需的庫 #\r打開你的cmd 一起快樂安裝\npip install discord.py youtube_dl pip install yt-dlp ffmpeg安裝 #\r前往\rBtbN FFmpeg Releases下載 ffmpeg-master-latest-win64-gpl.zip\n解壓縮後丟到一個不太會動到的地方\n接著打開環境變數，win11打開環境變數的方法如下\n設定 系統 系統資訊 進階系統設定 再來就能看到環境變數了\n接著選擇Path然後編輯，新增你剛剛解壓縮下來的檔案中bin資料夾的位置 (C:\\ffmpeg\\bin) 這樣就順利安裝完成了，可以檢查看看有沒有順利安裝，沒有的話就重開機看看\nffmpeg -version bot.py #\r主要可以分兩種撥放方式\n1.線上串流(較不穩定)\n2.下載到本機(很穩定)\n線上串流 #\r先講第一種線上串流的部分\n穩定性的部分就真的很爛 大概每首歌都撥不完 大概撥個一兩分鐘左右而已\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data) queue = asyncio.Queue() queue_urls = [] current_player = None # 用於儲存當前播放的音樂 @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Queue the song await queue.put(url) queue_urls.append(url) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {url}\u0026#34; for i, url in enumerate(queue_urls)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_list}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) # Optionally, automatically play the next song if not queue.empty(): await play_next_song(ctx, ctx.voice_client) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) async def play_next_song(ctx, voice_client): global current_player if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: player = await YTDLSource.from_url(url, loop=bot.loop, stream=True) current_player = player voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在撥放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song\u0026#39;) bot.run(\u0026#39;你的token\u0026#39;) 反正就又卡又容易斷掉 不如乖乖下載下來\n下載到本地 #\r因為是現在還有在用ㄉ，所以加了一些功能\n基本上就自己看一下code就能知道具體功能了 這邊就不多講了 然後下載到本地的話也不是全部下載，我是設定成一次本地只會有一首歌而已，然後撥下一首的時候就把前面的刪掉，所以不用怕自己電腦被灌爆 \u0026gt;.0\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio import os import datetime intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) self.duration = data.get(\u0026#39;duration\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data), filename queue = asyncio.Queue() queue_urls = [] current_player = None start_time = None downloaded_file = None # Only one file will be downloaded at a time @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Add the song to the queue await queue.put(url) queue_urls.append(url) # Get the song title to display the added message data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) await ctx.send(f\u0026#34;已將 {title} 加入待撥清單\u0026#34;) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = [] for url in queue_urls: data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) queue_list.append(title) queue_msg = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {title}\u0026#34; for i, title in enumerate(queue_list)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_msg}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) @bot.command() async def nowplay(ctx): if current_player: elapsed = (datetime.datetime.now() - start_time).total_seconds() elapsed_str = str(datetime.timedelta(seconds=int(elapsed))) duration_str = str(datetime.timedelta(seconds=int(current_player.duration))) progress_bar = create_progress_bar(elapsed, current_player.duration) await ctx.send(f\u0026#34;Now playing: {current_player.title}\\n{elapsed_str} {progress_bar} {duration_str}\u0026#34;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) def create_progress_bar(elapsed, duration, bar_length=20): progress = elapsed / duration bar = \u0026#39;-\u0026#39; * bar_length pos = int(bar_length * progress) progress_bar = bar[:pos] + \u0026#39;o\u0026#39; + bar[pos+1:] return progress_bar @bot.command() async def stop(ctx): if ctx.voice_client: if ctx.voice_client.is_playing(): ctx.voice_client.pause() await ctx.send(\u0026#39;已暫停播放.\u0026#39;) elif ctx.voice_client.is_paused(): ctx.voice_client.resume() await ctx.send(\u0026#39;已繼續播放.\u0026#39;) else: await ctx.send(\u0026#39;沒在播歌\u0026#39;) else: await ctx.send(\u0026#39;沒在語音中\u0026#39;) async def play_next_song(ctx, voice_client): global current_player, start_time, downloaded_file if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: # Delete the previous downloaded file if it exists if downloaded_file and os.path.isfile(downloaded_file): os.remove(downloaded_file) player, filename = await YTDLSource.from_url(url, loop=bot.loop, stream=False) current_player = player start_time = datetime.datetime.now() downloaded_file = filename # Update the downloaded file voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在播放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song.\u0026#39;) bot.run(\u0026#39;你ㄉtoken\u0026#39;) # 替換為你的實際 Bot Token 運行方法 #\r其實就只要運行py檔案就好了\n看你是要在cmd中執行還是直接在編譯器(我是用vs)跑都可以\npython bot.py 與chatGPT交流 #\r夢ㄉ開始 不知道為甚麼chatGPT一開始都是用java寫的，可能因為其實普遍都是用java寫吧，但我看不懂java所以都叫他寫python(\n其實好像也沒有甚麼特別要講的，基本上就都是想要什麼功能就講甚麼\n我覺得比較好玩的大概有nowplay功能而已 就是跟他說\u0026mdash;\u0026ndash;o\u0026mdash;-來表達進度條\n大概就這樣，有甚麼問題不要DM我，去問chatGPT這都他寫的(X\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/002_discordbot/","section":"Posts","summary":"謝謝ChatGPT讓我打遊戲的時候有歌可以聽","title":"DC音樂機器人製作","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/%E5%85%B6%E5%AE%83/","section":"Tags","summary":"","title":"其它","type":"tags"},{"content":"\r其實pre-exam也寫在這裡了 因為兩個沒差多少\r前言 #\r這次能打到前五真的覺得很不可思議，感覺今年題目有比較難\n雖然我也沒有打過之前的比賽就對了\n這次能打到第五名首先要特別感謝努力的自己 ，還有要特別感謝成大資安社還有B33F 50μP戰隊，提供了許多學習資源讓我學習 ，不過這次能打到那麼高真的覺得自己只是單純運氣好，比賽的時候想到比較多奇怪的方法，很多題還都是被我硬搓出來的\n而且賽後發現很多本來名次在我後面的，在pre-exam的名次都超過我了🛐\n建議想看比較正規解的人可以去看看別人的write up，我的真的都比較偏通靈向\n廢話夠多了，再來就進入到WriteUp的部分了\nScoreboard #\r先丟上自己的記分板還有賽後超長的記分板 我是MFCTF完整記分板\n我是pre-exam完整記分板\nMisc #\rWelcome #\r這次的Welcome沒有整活，單純點開題目描述就有了 flag:AIS3{Welc0me_to_AIS3_PreExam_2o24!}\n好歹也把pre-exam改成MFCTF吧 Quantum Nim Heist #\r這題是賽後在pre-exam才解出來的\r這題當初在MFCTF的時候是想說可能要先去破解他hash加密的部分\n然後自己找出把1加密後的結果再拿去讀檔\n所以MFCTF的時候想很久也沒有想出來該怎麼做\n結果賽後在pre-exam的時候無聊去亂試意外就找到破解的地方了\nsolve:\r如果一開始遊玩時亂輸入的話會顯示錯誤，因此就先正常進行遊戲動個幾步，後面直接按enter就會發現沒有報錯，而且對手也會動下一步\n因此再來就是等對手動到剩下最後一排的時候再去收割就好了 flag:AIS3{Ar3_y0u_a_N1m_ma57er_0r_a_Crypt0_ma57er?} Reverse #\rThe Long Print #\r先透過IDA查看反編譯後的代碼，主要可以發現在輸出的部分會重複執行sleep，因此無法直接透過執行來查看flag ，並且可以看到flag應該是存在v4也就是rsp的部分\n這邊再特別解釋一下，因為從上面反編譯後可以看到輸出後會再做V4\u0026gt;\u0026gt;=8的動作 因此這邊就是每次察看rsp的末兩位就好了 我一開始是透過gdb來在sleep的地方下斷點，然後直接jump到下一行，結果發現最後拚出來的flag怪怪的 其實這邊這個方法也可以 只是我當時看錯東西\n所以又去嘗試透過IDA先找到sleep的地方換成16進制檔案時在哪，再透過010Editor把那部分改成90，也就是不進行任何動作(這部分等等的火拳也會用到，會再詳細介紹)\nsolve:\r兩個方法其實後面要做的事情都差不多，都一樣是丟到gdb裡面，然後再printf的地方下斷點，並查看當時rsp的質，最後再轉成ASCII字元就好了 所以再來就一樣慢慢把flag搓出來 $rsp 的質: 0x3353494100000000 0x756f597b00000000 0x6572615f00000000 0x6568745f00000000 0x73616d5f00000000 0x5f72657400000000 0x745f666f00000000 0x5f656d6900000000 0x616e616d00000000 0x656d656700000000 0x2121746e00000000 0x7d3f212100000000 flag: AIS3{You_are_the_master_of_time_management!!!!?}\n火拳のエース #\r特別感謝Kazma在讀書會上分享angr這個工具 這題是透過angr來快速解出來的 Kazma的angr教學\n也沒有到秒解 還是想了很久\nsolve:\r一樣都先透過IDA查看反編譯後的代碼，發現跟之前自己練習angr官方Lab006使用到的觀念都差不多 主要都是把數據存在動態內存再去做混淆\r題目: lab006: 所以這邊直接偷Lab006的解來稍作修改\nimport angr import claripy import sys def main(argv): path_to_binary = argv[1] project = angr.Project(path_to_binary) start_address = 0x08049661 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password0 = claripy.BVS(\u0026#39;password0\u0026#39;, 64) password1 = claripy.BVS(\u0026#39;password1\u0026#39;, 64) password2 = claripy.BVS(\u0026#39;password2\u0026#39;, 64) password3 = claripy.BVS(\u0026#39;password3\u0026#39;, 64) fake_heap_address0 = 0xffffc93c pointer_to_malloc_memory_address0 = 0x090FB2D4 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness) fake_heap_address1 = 0xffffc94c pointer_to_malloc_memory_address1 = 0x090FB2D8 initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness) fake_heap_address2 = 0xffffc95c pointer_to_malloc_memory_address2 = 0x090FB2DC initial_state.memory.store(pointer_to_malloc_memory_address2, fake_heap_address2, endness=project.arch.memory_endness) fake_heap_address3 = 0xffffc96c pointer_to_malloc_memory_address3 = 0x090FB2E0 initial_state.memory.store(pointer_to_malloc_memory_address3, fake_heap_address3, endness=project.arch.memory_endness) initial_state.memory.store(fake_heap_address0, password0) initial_state.memory.store(fake_heap_address1, password1) initial_state.memory.store(fake_heap_address2, password2) initial_state.memory.store(fake_heap_address3, password3) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;Yes! I remember now, this is it!\u0026#39; in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;It feels slightly wrong, but almost correct...\u0026#39; in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode() solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode() print (solution0,solution1,solution2,solution3) else: raise Exception(\u0026#39;Could not find the solution\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main(sys.argv) 這邊不特別解釋angr的代碼在做什麼\n接著透過剛剛LongPrint提到的，透過16進制編輯器先把print_flag的部分刪掉，因為這邊我們直接透過strings就可以看到前半部分了 具體刪除的方法是先透過IDA在欲刪除的部分下斷點，然後開啟debug模式，接著到設定將Number of opcode bytes設成6，接著切回去就可以看到該段位於十六進制檔案中的何處了 接著就拿腳本去跑一次修改過後的檔案，發現居然錯了 後面想說那不如乾脆把與lab不同的地方(進行xor的部分)也乾脆先刪掉好了，因此重複上述操作，再去跑一次腳本，發現這次就有順利出現結果了！ 那接著就是把得到的質丟回去還有xor的檔案，接著透過gdb在進行xor後下斷點，查看xor後的質是多少 那最後flag也是順利被我搓出來了 這題大概是我這次最正規的解法了 flag:AIS3{G0D_D4MN_4N9R_15_5UP3R_P0W3RFU1!!!} Web #\rEvil Calculator #\rsolve:\r連進去發現是一個計算機，就很普通的計算機\r接著透過burp suite攔截發送1+1過去時的封包並送到Repeater查看 接著就嘗試修改1+1的部分，我先是嘗試看看能不能單純輸出字元，或是符號之類的 發現好像不能直接輸出，那接著猜測是不是只能數字，因此這邊使用簡單的len來查看，發現可以正常輸出，因此推測只要是轉成數字輸出後就可以 接著就根據題目給的檔案，知道了flag是在前一個目錄裡面，因此就嘗試結合len、read、跟Path Traversal去讀看看，發現也可以正常執行，並且知道了flag的長度為31 再來我的想法是，一個一個讀取flag的字元，因此一樣使用read只是將len改成ord來查看該字元換成ASCII為多少，但發現會報錯\n這邊直接把報錯貼到google去看，了解原來是因為直接read後就已經是數字了，不需要再透過ord去轉 因此最後直接就把ord去掉，再次察看就會發現有正常輸出了！\n然後就重複這個操作31次 flag就被我搓出來了呢 flag:AIS3{7RiANG13_5NAK3_I5_50_3Vi1}\nCrypto #\rbabyRSA #\r這題也是被我硬搓出來的 我對不起大家\nsolve:\r這邊先查看原代碼，可以發現它應該是對flag的每個字元去做個別加密的，因此最後輸出結果才會有那麼多\r這邊我想了很久，最後決定！\n對string.printable全部做一次加密 然後慢慢把flag對照搓出來 我的方法真的很笨 自己都看不下去的那種\nimport string def encrypt(pk, plaintext): key, n = pk cipher = [pow(ord(char), key, n) for char in plaintext] return cipher public=(64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) flag=string.printable print(flag) encrypted_msg = encrypt(public, flag) for i in range(len(flag)): print(flag[i],\u0026#34;=\u0026#34;,encrypted_msg[i]) 我是直接在記事本裡面慢慢用搜尋跟取代把flag搓出來啦，因為那個時候比賽快結束了，也懶得去想程式碼要怎麼寫，所以這邊就直接藉助了工人智慧 而且flag檔案的第一碼還不是A 害我當初困惑超久 所以後面才決定直接把全部都硬搓出來\nflag:AIS3{NeverUseTheCryptographyLibraryImplementedYourSelf}\n好欸終於寫完了\n然後如果發現我上述有錯誤的地方 都歡迎私訊我提醒我改一下\n相關問題 #\r這邊會比較偏我當初行前自己有疑惑的點，算是半個指引吧\r首先是交通的問題，這次舉辦的地點在救國團劍潭青年活動中心-集賢廳 (台北市中山北路四段16號)\n我自己是騎車過去啦，當初一直在想到底有沒有車位，後來其實發現在正門入口就有免費停車場了，而且還滿空的，因此大家可以放心騎車去了 再來是題目數量的部分，這次題目好像有比較多，以往好像都是各類型抓兩題，但這次是變成三題，不確定以後會不會也都是三題\n題目總覽 ","date":"30 June 2024","externalUrl":null,"permalink":"/posts/001_mfctf_writeup/","section":"Posts","summary":"2024ㄉMyFirstCTF跟pre-examㄉWriteUp","title":"2024 MyFirstCTF WriteUp","type":"posts"},{"content":"\r建立契機 #\r發現各大佬都有自己的網站，我也想要有一個\n當初打CTF在看別人寫的Write up就想著以後也要自己寫在部落格裡\n剛好想說可以創個地方來讓我寫各種資安相關的經歷\n因此這個網站主要內容也比較都會是以我的各種資安相關經歷為主\n網站簡介 #\r這個網站是透過\rHugo 建立，並套用了\rblowfish 主題\n然後我其實很不會寫網站 歡迎各位大神指導我\n網站歷史 #\r2024-5-27 網站創立\n","date":"31 May 2024","externalUrl":null,"permalink":"/intro/","section":"betan423.github.io","summary":"看看我ㄉ部落格歷史。","title":"網站簡介","type":"page"},{"content":"\r副標題\r段落標題 #\r換行 圖片 ","date":"23 April 2005","externalUrl":null,"permalink":"/%E9%A0%90%E8%A8%AD/","section":"betan423.github.io","summary":"複製用模板","title":"模板","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"\r看看我給未來的自己畫了多少餅\r資安相關規劃 #\r學習malware 正在啃《Windows APT Warfare：惡意程式前線戰術指南》 學好reverse跟pwn 每周CTF，小目標是最少要把warm up跟easy的題目都破台 ","date":"1 January 0001","externalUrl":null,"permalink":"/future/","section":"betan423.github.io","summary":"我ㄉ未來規劃。","title":"未來規劃","type":"page"},{"content":"\n這我 #\r嗨我是貝坦，一個誤打誤撞跑去學資安的怪人\n當初對於資安這塊完全沒概念，但大學不小心上了一個名子很長的資安系， 在經過一學期的各種講座洗禮以及自己稍微了解後，發現對於資安好像滿有興趣的， 結果就栽進這個無底洞了。\n資安經驗 #\r2024-4 加入B33F 50μP戰隊\n2024-8 參與2024 AIS3\n2024-8 臺灣好厲駭第九屆\n競賽經驗 #\r2024 My First CTF 銀質獎/第5名\n2024 AIS3 最佳專題獎\n","date":"1 January 0001","externalUrl":null,"permalink":"/authors/betan/","section":"Authors","summary":"","title":"我是貝坦betan","type":"authors"}]